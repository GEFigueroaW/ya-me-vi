<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YA ME VI - Combinaciones Sugeridas</title>
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="assets/favicon-circle.svg?v=6">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">
  
  <!-- Web App Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- PWA Meta -->
  <meta name="theme-color" content="#00B44F">
  <meta name="mobile-web-app-capable" content="yes">
  
  <!-- iOS Safari Meta -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="YA ME VI">
  
  <!-- iOS Touch Icon -->
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">
  
  <!-- Additional iOS Meta -->
  <meta name="format-detection" content="telephone=no">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <link rel="stylesheet" href="css/styles.css" />
  
  <!-- Google AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2226536008153511"
     crossorigin="anonymous"></script>
  
  <!-- AdSense Auto Ads -->
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-2226536008153511",
      enable_page_level_ads: true
    });
  </script>
     
  <style>
    /* Animaciones CSS mejoradas */
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.02); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* Estilos para contenidos expandibles */
    .contenido-expandible {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.5s ease-out, opacity 0.3s ease-in-out;
      opacity: 0;
    }
    
    .contenido-expandible.abierto {
      max-height: 1000px; /* Valor suficientemente grande */
      opacity: 1;
    }
    
    /* Efectos de hover para cajas */
    .box-container:hover {
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      transform: translateY(-2px);
    }
    
    /* Estilo para botones dentro de las cajas */
    button.btn-accion {
      transition: all 0.3s ease;
    }
    
    button.btn-accion:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .analizando {
      animation: pulse 1s infinite;
      background: linear-gradient(45deg, rgba(59, 130, 246, 0.2), rgba(99, 102, 241, 0.2));
      border: 1px solid rgba(99, 102, 241, 0.3);
    }
    
    .arrow-rotation {
      transition: transform 0.3s ease;
    }
  </style>
</head>

<body class="overflow-x-hidden" style="margin: 0; padding: 0;">
  <!-- Fondo - Sin transici√≥n para evitar parpadeo -->
  <div id="background" class="fixed inset-0 z-0 bg-cover bg-center" style="background-color: rgba(0, 0, 0, 0.9);"></div>
  
  <!-- Overlay - Reducida opacidad -->
  <div class="fixed inset-0 z-10 bg-black bg-opacity-30"></div>
  
  <!-- Contenido Principal -->
  <div class="relative z-20 min-h-screen">
    <!-- Bot√≥n de regreso -->
    <button id="btn-back" class="btn-back-improved">
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
      </svg>
      <span class="btn-text">Volver</span>
    </button>

    <!-- Espaciador para evitar solapamiento en m√≥viles -->
    <div class="mobile-spacer"></div>

    <!-- AdSense Ad Unit - Top of Sugeridas -->
    <div class="text-center mb-6">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-2226536008153511"
           data-ad-slot="8901234567"
           data-ad-format="auto"
           data-full-width-responsive="true"></ins>
      <script>
           (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    
    <!-- Encabezado -->
    <div class="text-center py-12">
      <h1 class="text-4xl md:text-5xl font-bold text-white mb-4 animate__animated animate__fadeInDown">
        Combinaciones Sugeridas
      </h1>
    </div>

    <!-- CAJA 1: Combinaciones Aleatorias -->
    <div class="max-w-4xl mx-auto mb-8 px-4">
      <div id="aleatorias-container" class="box-container bg-white bg-opacity-20 rounded-xl shadow-lg p-6 cursor-pointer transition-all duration-300 backdrop-blur-sm border border-white border-opacity-20" style="opacity: 0.8;" onclick="toggleAleatorias()">
        <div class="text-center">
          <h2 class="text-2xl font-bold text-white mb-2" style="color: white !important;">üé≤ Combinaciones Aleatorias</h2>
          <div class="flex items-center justify-center">
            <span class="text-white text-lg mr-2">Haz clic para ver</span>
            <div id="arrow-icon-aleatorias" class="arrow-rotation">‚ñº</div>
          </div>
        </div>
        
        <div id="contenido-aleatorias" class="contenido-expandible mt-6">
          <div class="text-center mb-6" onclick="event.stopPropagation()">
            <label class="text-white text-lg">¬øCu√°ntas combinaciones quieres?</label>
            <select id="cantidad-combinaciones" class="ml-4 px-4 py-2 rounded bg-white text-gray-800" onclick="event.stopPropagation()">
              <option value="1">1 combinaci√≥n</option>
              <option value="3">3 combinaciones</option>
              <option value="5">5 combinaciones</option>
              <option value="10">10 combinaciones</option>
            </select>
            <button onclick="event.stopPropagation(); generarAleatorias()" class="ml-4 btn-accion bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-bold py-2 px-6 rounded-full shadow-lg hover:shadow-xl transition-all duration-300">
              üé≤ Generar Aleatorias
            </button>
          </div>
          <div id="combinaciones-container" class="text-white text-center">
            <p>Selecciona cantidad y genera tus combinaciones</p>
          </div>
        </div>
      </div>
    </div>

    <!-- AdSense Ad Unit - Middle of Sugeridas -->
    <div class="text-center mt-8 mb-8">
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-client="ca-pub-2226536008153511"
           data-ad-slot="9012345678"
           data-ad-format="auto"
           data-full-width-responsive="true"></ins>
      <script>
           (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>

    <!-- CAJA 2: Predicciones IA -->
    <div class="max-w-4xl mx-auto mb-8 px-4">
      <div id="prediccion-container" class="box-container bg-white bg-opacity-20 rounded-xl shadow-lg p-6 cursor-pointer transition-all duration-300 backdrop-blur-sm border border-white border-opacity-20" style="opacity: 0.8;" onclick="togglePrediccionIA()">
        
        <div class="text-center">
          <h2 id="titulo-sorteo" class="text-2xl font-bold text-white mb-2" style="color: white !important;">üéØ Combinaciones sugeridas por IA - Cargando...</h2>
          <!-- Indicador de administrador -->
          <div id="admin-indicator" class="hidden bg-gradient-to-r from-yellow-400 to-orange-500 text-black text-sm font-bold px-3 py-1 rounded-full mx-auto mb-2 w-fit shadow-lg">
            üëë MODO ADMINISTRADOR - M√°xima Probabilidad Activada
          </div>
          <!-- Mensaje especial para administradores - SIEMPRE VISIBLE -->
          <div id="admin-message" class="hidden bg-gradient-to-r from-purple-600 to-pink-600 text-white text-xs font-semibold px-4 py-2 rounded-lg mx-auto mb-3 w-fit shadow-lg border border-white border-opacity-30">
            üëë PREDICCIONES ADMIN: Incluyen n√∫meros con m√°xima probabilidad
          </div>
          <div class="flex items-center justify-center">
            <span class="text-white text-lg mr-2">Haz clic para ver</span>
            <div id="arrow-icon" class="arrow-rotation">‚ñº</div>
          </div>
        </div>
        
        <div id="contenido-predicciones" class="contenido-expandible mt-6">
          <div class="grid md:grid-cols-3 gap-6 mb-6">
            <!-- Melate -->
            <div class="bg-blue-500 bg-opacity-20 rounded-lg p-4 text-center border border-blue-300 border-opacity-30">
              <div class="text-blue-100 text-lg font-semibold mb-3">üîµ Melate</div>
              <p id="combinacion-melate" class="text-lg font-bold tracking-wider text-blue-200 whitespace-nowrap">-- -- -- -- -- --</p>
            </div>
            
            <!-- Revancha -->
            <div class="bg-purple-500 bg-opacity-20 rounded-lg p-4 text-center border border-purple-300 border-opacity-30">
              <div class="text-purple-100 text-lg font-semibold mb-3">üü£ Revancha</div>
              <p id="combinacion-revancha" class="text-lg font-bold tracking-wider text-purple-200 whitespace-nowrap">-- -- -- -- -- --</p>
            </div>
            
            <!-- Revanchita -->
            <div class="bg-green-500 bg-opacity-20 rounded-lg p-4 text-center border border-green-300 border-opacity-30">
              <div class="text-green-100 text-lg font-semibold mb-3">üü¢ Revanchita</div>
              <p id="combinacion-revanchita" class="text-lg font-bold tracking-wider text-green-200 whitespace-nowrap">-- -- -- -- -- --</p>
            </div>
          </div>
          
          <div class="text-center">
            <p id="mensaje-estado" class="text-white text-sm mb-4">Predicciones completas de 5 m√©todos</p>
          </div>
        </div>
      </div>
    </div>

    <!-- CAJA 3: An√°lisis -->
    <div class="max-w-4xl mx-auto mb-8 px-4">
      <div id="analisis-container" class="box-container bg-white bg-opacity-20 rounded-xl shadow-lg p-6 cursor-pointer transition-all duration-300 backdrop-blur-sm border border-white border-opacity-20" style="opacity: 0.8;" onclick="toggleAnalisis()">
        
        <div class="text-center">
          <h2 class="text-2xl font-bold text-white mb-2" style="color: white !important;">üìä Proyecci√≥n basada en los 4 tipos de an√°lisis de los √∫ltimos sorteos</h2>
          <div class="flex items-center justify-center">
            <span class="text-white text-lg mr-2">Haz clic para ver</span>
            <div id="arrow-icon-analisis" class="arrow-rotation">‚ñº</div>
          </div>
        </div>
        
        <div id="contenido-analisis" class="contenido-expandible mt-6">
          <p class="text-center text-sm text-gray-300 mb-6">
            Combinaciones basadas en los 4 an√°lisis de los √∫ltimos 18 meses: frecuencias, suma de n√∫meros, balance pares/impares y d√©cadas por posici√≥n
          </p>
          
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <!-- Melate An√°lisis -->
            <div class="bg-red-500 bg-opacity-20 rounded-lg p-4 border border-red-300 border-opacity-30">
              <div class="text-red-100 text-lg font-semibold mb-2 text-center">üî¥ Melate</div>
              <p id="proyeccion-melate" class="text-lg font-bold tracking-wider text-red-200 mb-2 text-center">-- -- -- -- -- --</p>
            </div>
            
            <!-- Revancha An√°lisis -->
            <div class="bg-red-500 bg-opacity-20 rounded-lg p-4 border border-red-300 border-opacity-30">
              <div class="text-red-100 text-lg font-semibold mb-2 text-center">üî¥ Revancha</div>
              <p id="proyeccion-revancha" class="text-lg font-bold tracking-wider text-red-200 mb-2 text-center">-- -- -- -- -- --</p>
            </div>
            
            <!-- Revanchita An√°lisis -->
            <div class="bg-yellow-500 bg-opacity-20 rounded-lg p-4 border border-yellow-300 border-opacity-30">
              <div class="text-yellow-100 text-lg font-semibold mb-2 text-center">üü° Revanchita</div>
              <p id="proyeccion-revanchita" class="text-lg font-bold tracking-wider text-yellow-200 mb-2 text-center">-- -- -- -- -- --</p>
            </div>
          </div>
          
          <!-- Metodolog√≠a -->
          <div class="mt-8 text-center">
            <h3 class="text-lg font-semibold text-white mb-4">‚öôÔ∏è Metodolog√≠a de An√°lisis</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
              <div class="bg-white bg-opacity-10 rounded p-3">
                <div class="text-blue-300 font-semibold">25%</div>
                <div class="text-white">Frecuencias hist√≥ricas</div>
              </div>
              <div class="bg-white bg-opacity-10 rounded p-3">
                <div class="text-green-300 font-semibold">25%</div>
                <div class="text-white">Suma de n√∫meros</div>
              </div>
              <div class="bg-white bg-opacity-10 rounded p-3">
                <div class="text-purple-300 font-semibold">25%</div>
                <div class="text-white">Balance pares/impares</div>
              </div>
              <div class="bg-white bg-opacity-10 rounded p-3">
                <div class="text-yellow-300 font-semibold">25%</div>
                <div class="text-white">D√©cadas por posici√≥n</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- NUEVA CAJA 3: Predicci√≥n para el Pr√≥ximo Sorteo (Expandible) -->
    <div class="max-w-4xl mx-auto mb-8 px-4">
      <div id="prediccion-dia-container" class="box-container bg-white bg-opacity-20 rounded-xl shadow-lg p-6 cursor-pointer transition-all duration-300 backdrop-blur-sm border border-white border-opacity-20" style="opacity: 0.8;" onclick="togglePrediccionDia()">
        
        <div class="text-center">
          <h2 id="titulo-proximo-sorteo" class="text-2xl font-bold text-white mb-2" style="color: white !important;">üìÖ Predicci√≥n para el Pr√≥ximo Sorteo - Cargando...</h2>
          <p id="descripcion-proximo-sorteo" class="text-gray-200 text-sm mb-4">
            Predicciones espec√≠ficas basadas √∫nicamente en los sorteos del d√≠a correspondiente de los √∫ltimos 18 meses
          </p>
          <div class="flex items-center justify-center">
            <span class="text-white text-lg mr-2">Haz clic para ver</span>
            <div id="arrow-icon-dia" class="arrow-rotation">‚ñº</div>
          </div>
        </div>
        
        <div id="contenido-predicciones-dia" class="contenido-expandible mt-6">
          <!-- Contenedor de predicciones del pr√≥ximo sorteo -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <!-- Melate -->
            <div class="bg-blue-500 bg-opacity-20 rounded-lg p-4 border border-blue-300 border-opacity-30">
              <div class="text-blue-100 text-lg font-semibold mb-2 text-center">üîµ Melate</div>
              <p id="prediccion-melate-dia" class="text-lg font-bold tracking-wider text-blue-200 mb-2 text-center">-- -- -- -- -- --</p>
              <p id="stats-melate-dia" class="text-xs text-blue-200 text-center opacity-75"></p>
            </div>
            
            <!-- Revancha -->
            <div class="bg-red-500 bg-opacity-20 rounded-lg p-4 border border-red-300 border-opacity-30">
              <div class="text-red-100 text-lg font-semibold mb-2 text-center">üî¥ Revancha</div>
              <p id="prediccion-revancha-dia" class="text-lg font-bold tracking-wider text-red-200 mb-2 text-center">-- -- -- -- -- --</p>
              <p id="stats-revancha-dia" class="text-xs text-red-200 text-center opacity-75"></p>
            </div>
            
            <!-- Revanchita -->
            <div class="bg-yellow-500 bg-opacity-20 rounded-lg p-4 border border-red-300 border-opacity-30">
              <div class="text-yellow-100 text-lg font-semibold mb-2 text-center">üü° Revanchita</div>
              <p id="prediccion-revanchita-dia" class="text-lg font-bold tracking-wider text-yellow-200 mb-2 text-center">-- -- -- -- -- --</p>
              <p id="stats-revanchita-dia" class="text-xs text-yellow-200 text-center opacity-75"></p>
            </div>
          </div>
          
          <!-- Informaci√≥n del an√°lisis espec√≠fico por d√≠a -->
          <div class="mt-6 bg-white bg-opacity-5 rounded-lg p-4 border border-white border-opacity-10">
            <h3 class="text-lg font-semibold text-white mb-3 text-center">üîç An√°lisis Espec√≠fico del D√≠a</h3>
            <div id="info-analisis-dia" class="text-sm text-gray-200 text-center">
              Cargando informaci√≥n del an√°lisis...
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <footer class="bg-black bg-opacity-70 text-white text-xs text-center py-3 px-4 mt-8">
      <div class="mb-2">
        Este sistema se basa en estad√≠sticas, patrones, probabilidad e inteligencia artificial. No garantiza premios. Juega con responsabilidad.
      </div>
      <div class="space-x-2">
        <a href="aviso-legal.html" class="text-yellow-300 hover:text-yellow-100 underline transition duration-300">Aviso legal</a>
        <span class="text-gray-400">|</span>
        <a href="politica-privacidad.html" class="text-yellow-300 hover:text-yellow-100 underline transition duration-300">Pol√≠tica de privacidad</a>
      </div>
    </footer>
  </div>

  <!-- Scripts -->
  <script src="js/shared.js"></script>
  <script src="js/sistema-definitivo.js"></script>
  <script src="js/actualizarTituloSorteo.js"></script>
  <script src="js/webview-detector.js"></script>
  
  <script type="module">
    // === Detecci√≥n de entorno y carga de configuraci√≥n apropiada ===
    console.log('üîç Detectando entorno de ejecuci√≥n...');
    
    let firebaseModule;
    const isWebView = WebViewDetector.isWebView();
    const isWebIntoApp = WebViewDetector.isWebIntoApp();
    
    console.log('üì± Entorno detectado:', {
      isWebView,
      isWebIntoApp,
      userAgent: navigator.userAgent.slice(0, 100)
    });
    
    // Importar configuraci√≥n apropiada seg√∫n el entorno
    if (isWebView || isWebIntoApp) {
      console.log('üì± Cargando configuraci√≥n APK/WebView...');
      firebaseModule = await import('./js/firebase-init-apk.js');
    } else {
      console.log('üåê Cargando configuraci√≥n web est√°ndar...');
      firebaseModule = await import('./js/firebase-init.js');
    }
    
    // === Importaciones de Firebase ===
    const { getAuth, onAuthStateChanged } = await import("https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js");
    const { getFirestore, doc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js");
    
    const auth = getAuth(firebaseModule.app);
    const db = getFirestore(firebaseModule.app);

    // Variables globales para datos del usuario
    window.usuarioActualID = null;
    window.usuarioActualNombre = null;
    window.usuarioActualEmail = null;
    
    // === SISTEMA DE ADMINISTRADORES ===
    // Lista de emails de administradores (MISMA LISTA QUE admin.html)
    const ADMIN_EMAILS = [
      'gfigueroa.w@gmail.com', 
      'admin@yamevi.com.mx', 
      'eugenfw@gmail.com',
      'guillermo.figueroaw@totalplay.com.mx'
    ];
    
    // Funci√≥n para verificar si el usuario actual es administrador
    // MISMO CRITERIO QUE admin.html para consistencia
    async function esUsuarioAdmin() {
      try {
        if (!window.usuarioActualEmail) {
          console.log('üîç No hay email de usuario disponible para verificar admin');
          return false;
        }
        
        const emailUsuario = window.usuarioActualEmail.toLowerCase().trim();
        
        // Primera verificaci√≥n - por email directo (igual que admin.html)
        let esAdmin = ADMIN_EMAILS.includes(emailUsuario);
        
        if (esAdmin) {
          console.log('üëë USUARIO ADMINISTRADOR DETECTADO (email directo):', emailUsuario);
          return true;
        }
        
        // Segunda verificaci√≥n - por Firestore (igual que admin.html)
        if (!esAdmin && window.usuarioActualID) {
          try {
            console.log('üîç Verificando admin en Firestore para UID:', window.usuarioActualID);
            
            // Verificar que las funciones de Firestore est√©n disponibles
            if (typeof doc === 'undefined' || typeof getDoc === 'undefined') {
              console.log('‚ö†Ô∏è Funciones de Firestore no disponibles, omitiendo verificaci√≥n');
              return false;
            }
            
            const userRef = doc(db, 'users', window.usuarioActualID);
            const userSnap = await getDoc(userRef);
            
            if (userSnap.exists()) {
              const userData = userSnap.data();
              console.log('üìÑ Datos del usuario en Firestore:', userData);
              
              if (userData.isAdmin === true) {
                esAdmin = true;
                console.log('‚úÖ Admin confirmado por flag isAdmin en Firestore');
              } else if (userData.email && ADMIN_EMAILS.includes(userData.email.toLowerCase())) {
                esAdmin = true;
                console.log('‚úÖ Admin confirmado por email en Firestore');
              }
            }
          } catch (firestoreError) {
            console.warn('‚ö†Ô∏è Error verificando admin en Firestore:', firestoreError.message);
          }
        }
        
        if (esAdmin) {
          console.log('üëë USUARIO ADMINISTRADOR CONFIRMADO:', emailUsuario);
        } else {
          console.log('üë§ Usuario regular confirmado:', emailUsuario);
        }
        
        return esAdmin;
        
      } catch (error) {
        console.error('‚ùå Error en verificaci√≥n de administrador:', error);
        return false;
      }
    }
    
    // Variables globales para acceso r√°pido al estado de admin
    window.esUsuarioAdmin = esUsuarioAdmin;
    window.esAdmin = () => esUsuarioAdmin(); // Mantener compatibilidad
    
    // Funci√≥n simple para verificaci√≥n r√°pida de admin (sin Firestore)
    function esUsuarioAdminRapido() {
      if (!window.usuarioActualEmail) {
        return false;
      }
      
      const emailUsuario = window.usuarioActualEmail.toLowerCase().trim();
      return ADMIN_EMAILS.includes(emailUsuario);
    }
    
    // Exportar funci√≥n r√°pida tambi√©n
    window.esUsuarioAdminRapido = esUsuarioAdminRapido;
    
    // Exportar auth globalmente para que otros scripts puedan acceder al usuario actual
    window.auth = auth;

    // === Funci√≥n para obtener datos del usuario autenticado ===
    async function configurarUsuarioAutenticado(user) {
      try {
        console.log('üë§ Configurando usuario autenticado:', user.email);
        console.log('üîß Configuraci√≥n Firebase activa:', isWebView ? 'APK/WebView' : 'Web');
        
        // Configurar variables globales b√°sicas
        window.usuarioActualID = user.uid;
        window.usuarioActualEmail = user.email;
        window.usuarioActualNombre = user.displayName || null;
        
        // Intentar obtener informaci√≥n adicional de Firestore
        try {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await getDoc(userRef);
          
          if (userSnap.exists()) {
            const userData = userSnap.data();
            console.log('üìã Datos adicionales del usuario desde Firestore:', userData);
            
            // Actualizar con informaci√≥n de Firestore si est√° disponible
            if (userData.displayName || userData.name) {
              window.usuarioActualNombre = userData.displayName || userData.name;
            }
          }
        } catch (firestoreError) {
          console.log('‚ö†Ô∏è No se pudieron cargar datos adicionales de Firestore:', firestoreError.message);
        }
        
        console.log('‚úÖ Usuario configurado correctamente');
        console.log('- ID:', window.usuarioActualID);
        console.log('- Nombre:', window.usuarioActualNombre);
        console.log('- Email:', window.usuarioActualEmail);
        
        // ACTIVAR INDICADOR VISUAL DE ADMINISTRADOR
        setTimeout(async () => {
          try {
            const esAdmin = await esUsuarioAdmin();
            const adminIndicator = document.getElementById('admin-indicator');
            const adminMessage = document.getElementById('admin-message');
            
            if (esAdmin && adminIndicator) {
              adminIndicator.classList.remove('hidden');
              console.log('üëë Indicador visual de administrador activado');
            } else if (adminIndicator) {
              adminIndicator.classList.add('hidden');
            }
            
            if (esAdmin && adminMessage) {
              adminMessage.classList.remove('hidden');
              console.log('üëë Mensaje especial de administrador activado');
            } else if (adminMessage) {
              adminMessage.classList.add('hidden');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Error verificando estado de admin:', error);
          }
        }, 500);
        
        // La funci√≥n actualizarTituloSorteo.js se auto-ejecutar√° autom√°ticamente
        
        // CARGAR PREDICCIONES PERSISTENTES INMEDIATAMENTE
        setTimeout(() => {
          cargarPrediccionesPersistentesInmediato();
        }, 100);
        
        // FORZAR EJECUCI√ìN DE PREDICCIONES DESPU√âS DE UN TIEMPO
        setTimeout(() => {
          console.log('üîÑ Forzando ejecuci√≥n de predicciones si no hay resultados...');
          const melateCheck = document.getElementById('combinacion-melate');
          if (!melateCheck || melateCheck.textContent === '-- -- -- -- -- --' || melateCheck.textContent === 'Analizando...') {
            console.log('üöÄ Ejecutando predicciones forzadas...');
            if (window.ejecutarPrediccionesIA) {
              window.ejecutarPrediccionesIA();
            }
          }
        }, 3000); // 3 segundos
        
      } catch (error) {
        console.error('‚ùå Error configurando usuario:', error);
        // Fallback con datos b√°sicos
        window.usuarioActualID = user.uid;
        window.usuarioActualEmail = user.email;
        window.usuarioActualNombre = user.displayName || null;
      }
    }

    // === Verificaci√≥n de autenticaci√≥n ===
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        await configurarUsuarioAutenticado(user);
      } else {
        console.log('‚ùå Usuario no autenticado, redirigiendo a login');
        
        // Si est√° en WebView, usar p√°gina de login optimizada
        if (isWebView || isWebIntoApp) {
          console.log('üì± Redirigiendo a login optimizado para APK...');
          window.location.href = 'login-apk-compatible.html';
        } else {
          window.location.href = 'index.html';
        }
      }
    });
  </script>
  
  <script>
    // ==================== SISTEMA PRINCIPAL FUNCIONAL ====================
    
    // Variables globales
    let isAleatoriaOpen = false;
    let isPrediccionOpen = false;
    let isPrediccionDiaOpen = false;
    let isAnalisisOpen = false;
    
    // Inicializar background
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üöÄ Sistema iniciado');
      
      // Configurar background
      const backgrounds = [
        'assets/vg1.jpg',
        'assets/vg2.jpg', 
        'assets/vg3.jpg',
        'assets/vg4.jpg',
        'assets/vg5.jpg'
      ];
      
      const randomBg = backgrounds[Math.floor(Math.random() * backgrounds.length)];
      document.getElementById('background').style.backgroundImage = `url('${randomBg}')`;
      
      // Actualizar n√∫mero de sorteo cuando el usuario est√© disponible
      // La funci√≥n actualizarNumeroSorteo ser√° llamada desde configurarUsuarioAutenticado
      
      // Configurar bot√≥n de volver
      document.getElementById('btn-back').addEventListener('click', () => {
        console.log('üîô [SUGERIDAS] Regresando a home - marcando flag anti-loop');
        // Marcar que viene de regreso para evitar loop de onboarding
        localStorage.setItem('returned_from_page', 'true');
        localStorage.setItem('emergency_no_onboarding', 'true');
        window.location.href = 'home.html';
      });
      
      console.log('‚úÖ Sistema listo para usar');
    });
    
    // ==================== FUNCIONES TOGGLE ====================
    
    function toggleAleatorias() {
      console.log('üé≤ Toggle aleatorias');
      
      const contenido = document.getElementById('contenido-aleatorias');
      const arrow = document.getElementById('arrow-icon-aleatorias');
      const container = document.getElementById('aleatorias-container');
      
      if (!contenido || !arrow || !container) {
        console.error('‚ùå Elementos aleatorias no encontrados');
        return;
      }
      
      if (!isAleatoriaOpen) {
        // Abrir caja
        cerrarTodasLasCajas();
        contenido.classList.add('abierto');
        arrow.style.transform = 'rotate(180deg)';
        container.style.opacity = '1';
        isAleatoriaOpen = true;
        console.log('‚úÖ Caja aleatorias abierta');
      } else {
        // Cerrar caja y limpiar contenido
        contenido.classList.remove('abierto');
        arrow.style.transform = 'rotate(0deg)';
        container.style.opacity = '0.8';
        
        // Limpiar contenido y resetear selecci√≥n
        const combinacionesContainer = document.getElementById('combinaciones-container');
        const cantidadSelect = document.getElementById('cantidad-combinaciones');
        
        if (combinacionesContainer) {
          combinacionesContainer.innerHTML = '<p>Selecciona cantidad y genera tus combinaciones</p>';
        }
        if (cantidadSelect) {
          cantidadSelect.value = '1';
        }
        
        isAleatoriaOpen = false;
        console.log('‚úÖ Caja aleatorias cerrada y limpiada');
      }
    }
    
    function togglePrediccionIA() {
      console.log('ü§ñ Toggle predicci√≥n IA');
      
      const contenido = document.getElementById('contenido-predicciones');
      const arrow = document.getElementById('arrow-icon');
      const container = document.getElementById('prediccion-container');
      
      if (!contenido || !arrow || !container) {
        console.error('‚ùå Elementos predicci√≥n no encontrados');
        return;
      }
      
      if (!isPrediccionOpen) {
        // Abrir caja
        cerrarTodasLasCajas();
        contenido.classList.add('abierto');
        arrow.style.transform = 'rotate(180deg)';
        container.style.opacity = '1';
        isPrediccionOpen = true;
        console.log('‚úÖ Caja predicci√≥n abierta');
        
        // Verificar si ya hay predicciones generadas
        const melateElement = document.getElementById('combinacion-melate');
        if (!melateElement || melateElement.textContent === '-- -- -- -- -- --') {
          // Solo ejecutar predicciones IA si NO hay datos previos y NO hay predicciones persistentes
          console.log('üîç Verificando si existen predicciones persistentes antes de generar nuevas...');
          
          // Intentar cargar predicciones persistentes primero
          cargarPrediccionesPersistentesInmediato().then(() => {
            // Verificar nuevamente despu√©s de intentar cargar predicciones persistentes
            const melateElementCheck = document.getElementById('combinacion-melate');
            if (!melateElementCheck || melateElementCheck.textContent === '-- -- -- -- -- --') {
              // No hay predicciones persistentes, generar nuevas
              if (window.ejecutarPrediccionesIA) {
                console.log('ü§ñ Generando nuevas predicciones IA...');
                console.log('üîç Estado actual de elementos:', {
                  melate: melateElementCheck?.textContent,
                  usuarioID: window.usuarioActualID,
                  usuarioEmail: window.usuarioActualEmail
                });
                window.ejecutarPrediccionesIA();
              } else {
                console.error('‚ùå ejecutarPrediccionesIA no disponible');
                console.log('üîç Funciones disponibles en window:', Object.keys(window).filter(k => k.includes('ejecutar')));
              }
            } else {
              console.log('‚úÖ Predicciones persistentes encontradas, no se generan nuevas');
            }
          });
        } else {
          console.log('‚úÖ Ya hay predicciones mostradas, no se modifican');
        }
      } else {
        // Cerrar caja sin limpiar el contenido
        contenido.classList.remove('abierto');
        arrow.style.transform = 'rotate(0deg)';
        container.style.opacity = '0.8';
        isPrediccionOpen = false;
        console.log('‚úÖ Caja predicci√≥n cerrada');
        
        // No limpiamos las predicciones para mantenerlas disponibles
        // cuando el usuario vuelva a abrir la caja
        
        isPrediccionOpen = false;
        console.log('‚úÖ Caja predicci√≥n cerrada y limpiada');
      }
    }
    
    function toggleAnalisis() {
      console.log('üìä Toggle an√°lisis');
      
      const contenido = document.getElementById('contenido-analisis');
      const arrow = document.getElementById('arrow-icon-analisis');
      const container = document.getElementById('analisis-container');
      
      if (!contenido || !arrow || !container) {
        console.error('‚ùå Elementos an√°lisis no encontrados');
        return;
      }
      
      if (!isAnalisisOpen) {
        // Abrir caja
        cerrarTodasLasCajas();
        contenido.classList.add('abierto');
        arrow.style.transform = 'rotate(180deg)';
        container.style.opacity = '1';
        isAnalisisOpen = true;
        console.log('‚úÖ Caja an√°lisis abierta');
        
        // Ejecutar an√°lisis
        if (window.ejecutarAnalisisCompleto) {
          window.ejecutarAnalisisCompleto();
        } else {
          console.error('‚ùå ejecutarAnalisisCompleto no disponible');
        }
      } else {
        // Cerrar caja y limpiar contenido
        contenido.classList.remove('abierto');
        arrow.style.transform = 'rotate(0deg)';
        container.style.opacity = '0.8';
        
        // Limpiar resultados de an√°lisis
        const melateProyeccion = document.getElementById('proyeccion-melate');
        const revanchaProyeccion = document.getElementById('proyeccion-revancha');
        const revanchitaProyeccion = document.getElementById('proyeccion-revanchita');
        
        if (melateProyeccion) {
          melateProyeccion.textContent = '-- -- -- -- -- --';
        }
        if (revanchaProyeccion) {
          revanchaProyeccion.textContent = '-- -- -- -- -- --';
        }
        if (revanchitaProyeccion) {
          revanchitaProyeccion.textContent = '-- -- -- -- -- --';
        }
        
        isAnalisisOpen = false;
        console.log('‚úÖ Caja an√°lisis cerrada y limpiada');
      }
    }
    
    function togglePrediccionDia() {
      console.log('üìÖ Toggle predicci√≥n d√≠a');
      
      const contenido = document.getElementById('contenido-predicciones-dia');
      const arrow = document.getElementById('arrow-icon-dia');
      const container = document.getElementById('prediccion-dia-container');
      
      if (!contenido || !arrow || !container) {
        console.error('‚ùå Elementos predicci√≥n d√≠a no encontrados');
        return;
      }
      
      if (!isPrediccionDiaOpen) {
        // Abrir caja
        cerrarTodasLasCajas();
        contenido.classList.add('abierto');
        arrow.style.transform = 'rotate(180deg)';
        container.style.opacity = '1';
        isPrediccionDiaOpen = true;
        console.log('‚úÖ Caja predicci√≥n d√≠a abierta');
        
        // Verificar si ya hay predicciones del d√≠a cargadas
        const melateElement = document.getElementById('prediccion-melate-dia');
        if (!melateElement || melateElement.textContent === '-- -- -- -- -- --') {
          console.log('üîç Cargando predicciones espec√≠ficas por d√≠a...');
          // Cargar predicciones del pr√≥ximo sorteo si no est√°n cargadas
          setTimeout(() => {
            cargarPrediccionProximoSorteo();
          }, 300);
        }
      } else {
        // Cerrar caja
        contenido.classList.remove('abierto');
        arrow.style.transform = 'rotate(0deg)';
        container.style.opacity = '0.8';
        isPrediccionDiaOpen = false;
        console.log('‚úÖ Caja predicci√≥n d√≠a cerrada');
      }
    }
    
    function cerrarTodasLasCajas() {
      // Cerrar aleatorias
      if (isAleatoriaOpen) {
        const contenido = document.getElementById('contenido-aleatorias');
        const arrow = document.getElementById('arrow-icon-aleatorias');
        const container = document.getElementById('aleatorias-container');
        const combinacionesContainer = document.getElementById('combinaciones-container');
        const cantidadSelect = document.getElementById('cantidad-combinaciones');
        
        if (contenido && arrow && container) {
          contenido.classList.remove('abierto');
          arrow.style.transform = 'rotate(0deg)';
          container.style.opacity = '0.8';
        }
        
        // Limpiar contenido y resetear selecci√≥n
        if (combinacionesContainer) {
          combinacionesContainer.innerHTML = '<p>Selecciona cantidad y genera tus combinaciones</p>';
        }
        if (cantidadSelect) {
          cantidadSelect.value = '1';
        }
        
        isAleatoriaOpen = false;
        console.log('‚úÖ Caja aleatorias cerrada y limpiada');
      }
      
      // Cerrar predicci√≥n
      if (isPrediccionOpen) {
        const contenido = document.getElementById('contenido-predicciones');
        const arrow = document.getElementById('arrow-icon');
        const container = document.getElementById('prediccion-container');
        if (contenido && arrow && container) {
          contenido.classList.remove('abierto');
          arrow.style.transform = 'rotate(0deg)';
          container.style.opacity = '0.8';
        }
        
        // NO limpiamos los resultados de predicciones para mantener la consistencia
        // cuando el usuario vuelva a abrir la caja
        
        isPrediccionOpen = false;
        console.log('‚úÖ Caja predicci√≥n cerrada (datos preservados)');
      }
      
      // Cerrar an√°lisis
      if (isAnalisisOpen) {
        const contenido = document.getElementById('contenido-analisis');
        const arrow = document.getElementById('arrow-icon-analisis');
        const container = document.getElementById('analisis-container');
        
        if (contenido && arrow && container) {
          contenido.classList.remove('abierto');
          arrow.style.transform = 'rotate(0deg)';
          container.style.opacity = '0.8';
        }
        
        // Limpiar resultados de an√°lisis
        const melateProyeccion = document.getElementById('proyeccion-melate');
        const revanchaProyeccion = document.getElementById('proyeccion-revancha');
        const revanchitaProyeccion = document.getElementById('proyeccion-revanchita');
        
        if (melateProyeccion) {
          melateProyeccion.textContent = '-- -- -- -- -- --';
        }
        if (revanchaProyeccion) {
          revanchaProyeccion.textContent = '-- -- -- -- -- --';
        }
        if (revanchitaProyeccion) {
          revanchitaProyeccion.textContent = '-- -- -- -- -- --';
        }
        
        isAnalisisOpen = false;
        console.log('‚úÖ Caja an√°lisis cerrada y limpiada');
      }
      
      // Cerrar predicci√≥n d√≠a
      if (isPrediccionDiaOpen) {
        const contenido = document.getElementById('contenido-predicciones-dia');
        const arrow = document.getElementById('arrow-icon-dia');
        const container = document.getElementById('prediccion-dia-container');
        
        if (contenido && arrow && container) {
          contenido.classList.remove('abierto');
          arrow.style.transform = 'rotate(0deg)';
          container.style.opacity = '0.8';
        }
        
        // NO limpiamos los resultados para mantener consistencia
        // Las predicciones del d√≠a se mantienen cargadas
        
        isPrediccionDiaOpen = false;
        console.log('‚úÖ Caja predicci√≥n d√≠a cerrada (datos preservados)');
      }
    }
    
    // ==================== FUNCI√ìN ALEATORIAS ====================
    
    function generarAleatorias() {
      console.log('üé≤ Generando combinaciones aleatorias');
      
      const cantidad = parseInt(document.getElementById('cantidad-combinaciones').value);
      const container = document.getElementById('combinaciones-container');
      
      // Mostrar loading
      container.innerHTML = '<div class="text-center"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white mx-auto mb-4"></div><p>Generando combinaciones...</p></div>';
      
      setTimeout(() => {
        const combinaciones = [];
        for (let i = 0; i < cantidad; i++) {
          const numeros = new Set();
          while (numeros.size < 6) {
            numeros.add(Math.floor(Math.random() * 56) + 1);
          }
          combinaciones.push(Array.from(numeros).sort((a, b) => a - b));
        }
        
        let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';
        combinaciones.forEach((combo, index) => {
          html += `
            <div class="bg-purple-500 bg-opacity-20 rounded-lg p-4 text-center border border-purple-300 border-opacity-30">
              <h4 class="text-lg font-semibold text-white mb-2">Combinaci√≥n ${index + 1}</h4>
              <div class="flex justify-center space-x-2 mb-3 flex-wrap">
                ${combo.map(num => `<span class="bg-white text-purple-600 font-bold py-1 px-2 rounded text-sm m-1">${num}</span>`).join('')}
              </div>
            </div>
          `;
        });
        html += '</div>';
        
        container.innerHTML = html;
        console.log(`‚úÖ ${cantidad} combinaciones generadas`);
      }, 800);
    }
    
    function copiarCombinacion(combinacion) {
      navigator.clipboard.writeText(combinacion).then(() => {
        const mensaje = document.createElement('div');
        mensaje.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg z-50';
        mensaje.textContent = '‚úÖ Combinaci√≥n copiada';
        document.body.appendChild(mensaje);
        setTimeout(() => mensaje.remove(), 2000);
      }).catch(() => {
        alert('Combinaci√≥n: ' + combinacion);
      });
    }
    
    // ==================== FUNCI√ìN PREDICCIONES IA CON AN√ÅLISIS REAL ====================
    
    // Variables para controlar la versi√≥n de las predicciones (PERSISTENTE)
    let prediccionesPorUsuarioYHash = {};
    let datosAnalisisCompleto = null;
    let csvHashActual = null;
    let csvHashCalculado = false;
    
    // Funci√≥n para generar ID √∫nico robusto del usuario (m√°xima diferenciaci√≥n pero ESTABLE)
    function generarIDUsuarioUnico() {
      try {
        console.log('üîê Generando ID √∫nico robusto ESTABLE para m√°xima diferenciaci√≥n...');
        
        let factoresUnicos = [];
        
        // Factor 1: ID de Firebase (principal) - ESTABLE
        if (window.usuarioActualID && window.usuarioActualID.trim()) {
          factoresUnicos.push(window.usuarioActualID.trim());
        }
        
        // Factor 2: Email completo (diferenciaci√≥n adicional) - ESTABLE
        if (window.usuarioActualEmail && window.usuarioActualEmail.trim()) {
          factoresUnicos.push(window.usuarioActualEmail.trim());
        }
        
        // Factor 3: Nombre completo (m√°s diferenciaci√≥n) - ESTABLE
        if (window.usuarioActualNombre && window.usuarioActualNombre.trim()) {
          factoresUnicos.push(window.usuarioActualNombre.trim());
        }
        
        // Factor 4: Hora de creaci√≥n de cuenta o timestamp √∫nico - ESTABLE
        if (window.usuarioActualID) {
          // Los IDs de Firebase incluyen timestamp, extraer componentes √∫nicos
          const idParts = window.usuarioActualID.split('').slice(0, 20); // Primeros 20 caracteres
          factoresUnicos.push(idParts.join(''));
        }
        
        // Factor 5: Fingerprint del navegador (para usuarios an√≥nimos) - ESTABLE
        const navigatorFingerprint = [
          navigator.userAgent,
          navigator.language,
          screen.width + 'x' + screen.height,
          new Date().getTimezoneOffset(),
          (navigator.platform || 'unknown')
        ].join('|');
        factoresUnicos.push(navigatorFingerprint);
        
        // Factor 6: Informaci√≥n adicional del dispositivo/navegador - ESTABLE
        try {
          const deviceInfo = [
            navigator.hardwareConcurrency || 'unknown',
            navigator.deviceMemory || 'unknown',
            navigator.maxTouchPoints || 'unknown',
            screen.colorDepth || 'unknown',
            screen.pixelDepth || 'unknown',
            window.devicePixelRatio || 'unknown'
          ].join('|');
          factoresUnicos.push(deviceInfo);
        } catch (e) {
          factoresUnicos.push('device_unknown');
        }
        
        // Factor 7: Identificador de sesi√≥n PERSISTENTE (solo se genera una vez por usuario)
        let sessionIdPersistente = '';
        try {
          // Intentar recuperar sessionId persistente del localStorage
          const keySessionId = `yaViSessionId_${window.usuarioActualID || 'anon'}`;
          sessionIdPersistente = localStorage.getItem(keySessionId);
          
          if (!sessionIdPersistente) {
            // Generar nuevo sessionId solo si no existe
            sessionIdPersistente = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem(keySessionId, sessionIdPersistente);
            console.log('üÜï Nuevo sessionId persistente generado');
          } else {
            console.log('üîÑ SessionId persistente recuperado del localStorage');
          }
        } catch (e) {
          // Fallback si localStorage no est√° disponible
          sessionIdPersistente = 'session_fallback_' + (window.usuarioActualID || 'anon');
          console.warn('‚ö†Ô∏è Usando sessionId de fallback');
        }
        
        factoresUnicos.push(sessionIdPersistente);
        
        // Combinar todos los factores ESTABLES
        const combinacionFactores = factoresUnicos.join('|||STABLE|||');
        
        // Generar hash robusto y extraer componentes √∫nicos
        const hashPrincipal = generarHashSimple(combinacionFactores);
        const hashSecundario = generarHashSimple(combinacionFactores.split('').reverse().join(''));
        const hashTerciario = generarHashSimple(factoresUnicos.join('***FINAL***'));
        
        // Crear ID final s√∫per √∫nico pero ESTABLE
        const idUnico = `${hashPrincipal}_${hashSecundario}_${hashTerciario}`;
        
        console.log(`‚úÖ ID √∫nico ESTABLE generado: ${idUnico.substring(0, 16)}... (truncado para log)`);
        console.log(`üéØ Factores √∫nicos utilizados: ${factoresUnicos.length}`);
        
        return idUnico;
        
      } catch (error) {
        console.error('‚ùå Error generando ID √∫nico:', error);
        
        // Fallback robusto ESTABLE
        const fallbackId = 'fallback_' + (window.usuarioActualID || 'anon') + '_stable';
        console.log(`‚ö†Ô∏è Usando ID de fallback ESTABLE: ${fallbackId}`);
        return fallbackId;
      }
    }
    
    // Funci√≥n para calcular hash robusto de los archivos CSV
    async function calcularHashCSV() {
      if (csvHashCalculado && csvHashActual !== null) {
        console.log(`üîí Usando hash CSV en cach√©: ${csvHashActual}`);
        return csvHashActual;
      }
      
      try {
        console.log('üî¢ Calculando hash CSV de archivos...');
        
        const [melateResponse, revanchaResponse, revanchitaResponse] = await Promise.all([
          fetch('assets/Melate.csv'),
          fetch('assets/Revancha.csv'),
          fetch('assets/Revanchita.csv')
        ]);
        
        const [melateText, revanchaText, revanchitaText] = await Promise.all([
          melateResponse.text(),
          revanchaResponse.text(),
          revanchitaResponse.text()
        ]);
        
        // Crear hash basado en el contenido de los 3 archivos CSV
        const contenidoCombinado = melateText + revanchaText + revanchitaText;
        const hash = generarHashSimple(contenidoCombinado);
        
        csvHashActual = hash.toString();
        csvHashCalculado = true;
        
        console.log(`‚úÖ Hash CSV calculado: ${csvHashActual}`);
        
        // Guardar el hash en localStorage para persistencia entre sesiones
        try {
          localStorage.setItem('yaViCSVHash', csvHashActual);
          console.log('üíæ Hash CSV guardado en localStorage');
        } catch (e) {
          console.warn('‚ö†Ô∏è No se pudo guardar hash en localStorage:', e);
        }
        
        return csvHashActual;
      } catch (error) {
        console.error('‚ùå Error calculando hash CSV:', error);
        
        // Intentar recuperar hash del localStorage
        try {
          const hashGuardado = localStorage.getItem('yaViCSVHash');
          if (hashGuardado) {
            csvHashActual = hashGuardado;
            csvHashCalculado = true;
            console.log(`üîÑ Hash CSV recuperado del localStorage: ${csvHashActual}`);
            return csvHashActual;
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è No se pudo recuperar hash del localStorage:', e);
        }
        
        // Fallback: usar fecha como hash (se actualizar√° cuando cambien los CSV)
        const fechaHash = new Date().toDateString();
        csvHashActual = generarHashSimple(fechaHash).toString();
        csvHashCalculado = true;
        console.log(`‚ö†Ô∏è Usando hash de fallback basado en fecha: ${csvHashActual}`);
        return csvHashActual;
      }
    }
    
    // Funci√≥n para cargar predicciones persistentes del localStorage
    function cargarPrediccionesPersistentes() {
      try {
        const prediccionesGuardadas = localStorage.getItem('yaViPrediccionesIA');
        if (prediccionesGuardadas) {
          prediccionesPorUsuarioYHash = JSON.parse(prediccionesGuardadas);
          console.log('üíæ Predicciones persistentes cargadas del localStorage');
          console.log('üìä Claves disponibles:', Object.keys(prediccionesPorUsuarioYHash));
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error cargando predicciones del localStorage:', error);
        prediccionesPorUsuarioYHash = {};
      }
    }
    
    // Funci√≥n para guardar predicciones en localStorage
    function guardarPrediccionesPersistentes() {
      try {
        localStorage.setItem('yaViPrediccionesIA', JSON.stringify(prediccionesPorUsuarioYHash));
        console.log('üíæ Predicciones guardadas en localStorage');
      } catch (error) {
        console.warn('‚ö†Ô∏è Error guardando predicciones en localStorage:', error);
      }
    }
    
    // Ejecutar predicciones de IA con an√°lisis estad√≠stico real (PERSISTENTE)
    async function ejecutarPrediccionesIA() {
      console.log('ü§ñ Ejecutando predicciones IA con an√°lisis estad√≠stico avanzado');
      
      const melateElement = document.getElementById('combinacion-melate');
      const revanchaElement = document.getElementById('combinacion-revancha');
      const revanchitaElement = document.getElementById('combinacion-revanchita');
      const mensajeEstado = document.getElementById('mensaje-estado');
      
      // Cargar predicciones persistentes al inicio
      cargarPrediccionesPersistentes();
      
      // GENERAR ID √öNICO ROBUSTO PARA M√ÅXIMA DIFERENCIACI√ìN ENTRE USUARIOS
      let usuarioId = generarIDUsuarioUnico();
      
      // Para mostrar en el t√≠tulo, usar el nombre real del usuario
      let nombreUsuario = 'TI';
      if (window.usuarioActualNombre && window.usuarioActualNombre.trim()) {
        nombreUsuario = window.usuarioActualNombre.trim().split(' ')[0];
      } else if (window.usuarioActualEmail && window.usuarioActualEmail.trim()) {
        const emailPart = window.usuarioActualEmail.trim().split('@')[0];
        nombreUsuario = emailPart.replace(/[._\d]/g, '');
        nombreUsuario = nombreUsuario.charAt(0).toUpperCase() + nombreUsuario.slice(1).toLowerCase();
      } else if (window.usuarioActualID && window.usuarioActualID.trim()) {
        nombreUsuario = `Usuario${window.usuarioActualID.substring(0, 4)}`;
      }
      
      try {
        // Calcular hash CSV de forma robusta
        await calcularHashCSV();
        
        // Actualizar t√≠tulo del sorteo si es necesario
        if (window.actualizarTituloSorteo) {
          await window.actualizarTituloSorteo();
        }
        
        const claveUsuarioHash = `${usuarioId}_${csvHashActual}`;
        
        // VERIFICAR PREDICCIONES PERSISTENTES - PRIORIDAD M√ÅXIMA
        if (prediccionesPorUsuarioYHash[claveUsuarioHash]) {
          const predicciones = prediccionesPorUsuarioYHash[claveUsuarioHash];
          if (melateElement) melateElement.textContent = predicciones.melate;
          if (revanchaElement) revanchaElement.textContent = predicciones.revancha;
          if (revanchitaElement) revanchitaElement.textContent = predicciones.revanchita;
          
          // INDICADOR PARA ADMINISTRADORES
          const esAdmin = await esUsuarioAdmin();
          const mensajeEstadoTexto = esAdmin ? 
            'üëë PREDICCIONES ADMIN: Incluyen n√∫meros con m√°xima probabilidad (persistentes)' : 
            'Predicciones completas de 5 m√©todos (persistentes)';
          
          if (mensajeEstado) mensajeEstado.textContent = mensajeEstadoTexto;
          console.log(`üîí Usando predicciones PERSISTENTES para ${nombreUsuario} (Hash: ${csvHashActual})`);
          console.log(`üìã Predicciones cargadas desde cach√© persistente`);
          return;
        }
        
        console.log(`üîÑ Generando NUEVAS predicciones para ${nombreUsuario} (Hash: ${csvHashActual})`);
        
        // Mostrar estado "analizando"
        if (melateElement) melateElement.textContent = 'Analizando...';
        if (revanchaElement) revanchaElement.textContent = 'Analizando...';
        if (revanchitaElement) revanchitaElement.textContent = 'Analizando...';
        if (mensajeEstado) mensajeEstado.textContent = 'Aplicando 5 m√©todos: frecuencias, probabilidad, patrones, desviaci√≥n est√°ndar e IA...';
        
        // Cargar y analizar datos reales
        const datosReales = await cargarDatosRealesParaIA();
        
        setTimeout(async () => {
          // Generar predicciones usando an√°lisis estad√≠stico real
          const nuevasPredicciones = generarPrediccionesConIA(datosReales, usuarioId, csvHashActual);
          
          // Guardar en cach√© EN MEMORIA
          prediccionesPorUsuarioYHash[claveUsuarioHash] = nuevasPredicciones;
          
          // Guardar PERSISTENTEMENTE en localStorage
          guardarPrediccionesPersistentes();
          
          // Mostrar resultados con indicador de administrador
          if (melateElement) melateElement.textContent = nuevasPredicciones.melate;
          if (revanchaElement) revanchaElement.textContent = nuevasPredicciones.revancha;
          if (revanchitaElement) revanchitaElement.textContent = nuevasPredicciones.revanchita;
          
          // INDICADOR PARA ADMINISTRADORES EN NUEVAS PREDICCIONES
          const esAdmin = await esUsuarioAdmin();
          const mensajeEstadoTexto = esAdmin ? 
            'üëë PREDICCIONES ADMIN: Incluyen n√∫meros con m√°xima probabilidad (reci√©n generadas)' : 
            'Predicciones completas: an√°lisis estad√≠stico + IA (persistentes)';
          
          if (mensajeEstado) mensajeEstado.textContent = mensajeEstadoTexto;
          
          console.log(`‚úÖ Nuevas predicciones IA generadas y GUARDADAS PERSISTENTEMENTE para ${nombreUsuario}`);
          console.log(`üîê Hash CSV: ${csvHashActual}`);
        }, 1500);
        
      } catch (error) {
        console.error('‚ùå Error en predicciones IA:', error);
        
        // Fallback usando el sistema existente pero mejorado
        const prediccionesFallback = generarPrediccionesFallback(usuarioId, csvHashActual || 'fallback');
        
        if (melateElement) melateElement.textContent = prediccionesFallback.melate;
        if (revanchaElement) revanchaElement.textContent = prediccionesFallback.revancha;
        if (revanchitaElement) revanchitaElement.textContent = prediccionesFallback.revanchita;
        if (mensajeEstado) mensajeEstado.textContent = 'Predicciones generadas (modo fallback)';
      }
    }
    
    // Funci√≥n para cargar datos reales de los CSV
    async function cargarDatosRealesParaIA() {
      console.log('üìä Cargando datos reales para an√°lisis IA...');
      
      const archivos = ['assets/Melate.csv', 'assets/Revancha.csv', 'assets/Revanchita.csv'];
      const sorteos = ['melate', 'revancha', 'revanchita'];
      const datos = {};
      
      for (let i = 0; i < archivos.length; i++) {
        const archivo = archivos[i];
        const sorteo = sorteos[i];
        
        try {
          const response = await fetch(archivo);
          if (!response.ok) continue;
          
          const csvText = await response.text();
          const lineas = csvText.trim().split('\n');
          
          if (lineas.length < 2) continue;
          
          const numeros = [];
          const frecuencias = {};
          const sumaTotal = [];
          
          // Procesar √∫ltimos 18 meses de datos
          for (let j = 1; j < Math.min(lineas.length, 72); j++) { // ~72 sorteos = 18 meses
            const linea = lineas[j].trim();
            if (!linea) continue;
            
            const columnas = linea.split(',');
            const numerosLinea = [];
            
            // Extraer n√∫meros seg√∫n el formato
            const startCol = 2;
            const endCol = 7;
            
            for (let k = startCol; k <= endCol; k++) {
              const num = parseInt(columnas[k]);
              if (!isNaN(num) && num >= 1 && num <= 56) {
                numerosLinea.push(num);
                numeros.push(num);
                frecuencias[num] = (frecuencias[num] || 0) + 1;
              }
            }
            
            if (numerosLinea.length === 6) {
              sumaTotal.push(numerosLinea.reduce((a, b) => a + b, 0));
            }
          }
          
          // Calcular estad√≠sticas
          const estadisticas = calcularEstadisticas(numeros, frecuencias, sumaTotal);
          
          datos[sorteo] = {
            numeros: numeros,
            frecuencias: frecuencias,
            estadisticas: estadisticas,
            totalSorteos: Math.floor(numeros.length / 6)
          };
          
        } catch (error) {
          console.error(`Error cargando ${archivo}:`, error);
        }
      }
      
      return datos;
    }
    
    // Funci√≥n para calcular estad√≠sticas avanzadas
    function calcularEstadisticas(numeros, frecuencias, sumas) {
      const totalNumeros = numeros.length;
      
      // 1. Frecuencias normalizadas
      const frecuenciasNorm = {};
      for (let i = 1; i <= 56; i++) {
        frecuenciasNorm[i] = (frecuencias[i] || 0) / totalNumeros;
      }
      
      // 2. Desviaci√≥n est√°ndar de frecuencias
      const promFrec = totalNumeros / 56;
      let sumaCuadrados = 0;
      for (let i = 1; i <= 56; i++) {
        sumaCuadrados += Math.pow((frecuencias[i] || 0) - promFrec, 2);
      }
      const desviacionEstandar = Math.sqrt(sumaCuadrados / 56);
      
      // 3. An√°lisis de sumas
      const promSuma = sumas.reduce((a, b) => a + b, 0) / sumas.length;
      const sumaMin = Math.min(...sumas);
      const sumaMax = Math.max(...sumas);
      
      // 4. N√∫meros calientes y fr√≠os
      const sortedFreqs = Object.entries(frecuencias).sort((a, b) => b[1] - a[1]);
      const calientes = sortedFreqs.slice(0, 14).map(([num]) => parseInt(num));
      const frios = sortedFreqs.slice(-14).map(([num]) => parseInt(num));
      
      // === NUEVOS FACTORES AVANZADOS PARA MEJORAR PREDICCIONES ===
      
      // 5. An√°lisis de ciclos y patrones temporales
      const analisisCiclos = analizarCiclosTemporales(numeros, sumas);
      
      // 6. An√°lisis de gaps (espacios entre apariciones)
      const analisisGaps = analizarGapsNumeros(frecuencias, totalNumeros);
      
      // 7. An√°lisis de pares/parejas frecuentes
      const analisisPares = analizarParejasRecurrentes(numeros);
      
      // 8. An√°lisis de distribuci√≥n por d√©cadas
      const analisisDecadas = analizarDistribucionDecadas(numeros);
      
      // 9. An√°lisis de balance par/impar optimizado
      const analisisParImpar = analizarBalanceParImpar(numeros);
      
      // 10. An√°lisis de secuencias y saltos
      const analisisSecuencias = analizarSecuenciasYSaltos(numeros);
      
      // 11. An√°lisis de regresi√≥n a la media
      const analisisRegresion = analizarRegresionMedia(frecuencias, totalNumeros);
      
      return {
        frecuenciasNorm,
        desviacionEstandar,
        promSuma,
        sumaMin,
        sumaMax,
        calientes,
        frios,
        totalSorteos: Math.floor(totalNumeros / 6),
        // Nuevos factores avanzados
        ciclos: analisisCiclos,
        gaps: analisisGaps,
        pares: analisisPares,
        decadas: analisisDecadas,
        parImpar: analisisParImpar,
        secuencias: analisisSecuencias,
        regresion: analisisRegresion
      };
    }
    
    // === FUNCIONES DE AN√ÅLISIS AVANZADO PARA MEJORAR PREDICCIONES ===
    
    // 5. An√°lisis de ciclos y patrones temporales
    function analizarCiclosTemporales(numeros, sumas) {
      const ultimosSorteos = Math.min(60, Math.floor(numeros.length / 6)); // √öltimos 60 sorteos
      const cicloCorto = [];
      const cicloMedio = [];
      
      // Analizar √∫ltimos 10 sorteos (ciclo corto)
      for (let i = 0; i < Math.min(10, ultimosSorteos) * 6; i += 6) {
        const sorteo = numeros.slice(i, i + 6);
        cicloCorto.push(...sorteo);
      }
      
      // Analizar √∫ltimos 30 sorteos (ciclo medio) 
      for (let i = 0; i < Math.min(30, ultimosSorteos) * 6; i += 6) {
        const sorteo = numeros.slice(i, i + 6);
        cicloMedio.push(...sorteo);
      }
      
      // Frecuencias en ciclos
      const frecCicloCorto = {};
      const frecCicloMedio = {};
      
      cicloCorto.forEach(num => frecCicloCorto[num] = (frecCicloCorto[num] || 0) + 1);
      cicloMedio.forEach(num => frecCicloMedio[num] = (frecCicloMedio[num] || 0) + 1);
      
      // Tendencias ascendentes/descendentes
      const tendencias = {};
      for (let i = 1; i <= 56; i++) {
        const freqCorto = frecCicloCorto[i] || 0;
        const freqMedio = frecCicloMedio[i] || 0;
        tendencias[i] = freqCorto - (freqMedio / 3); // Comparar tendencia reciente vs media
      }
      
      return {
        frecCicloCorto,
        frecCicloMedio,
        tendencias,
        numerosCalientesRecientes: Object.entries(frecCicloCorto)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 12)
          .map(([num]) => parseInt(num))
      };
    }
    
    // 6. An√°lisis de gaps (espacios entre apariciones)
    function analizarGapsNumeros(frecuencias, totalNumeros) {
      const gaps = {};
      const ultimaAparicion = {};
      const totalSorteos = Math.floor(totalNumeros / 6);
      
      // Calcular gaps promedio y actual para cada n√∫mero
      for (let i = 1; i <= 56; i++) {
        const freq = frecuencias[i] || 0;
        if (freq > 0) {
          gaps[i] = {
            promedio: totalSorteos / freq,
            frecuencia: freq,
            probabilidadProxima: 1 / (totalSorteos / freq) // Probabilidad basada en gap promedio
          };
        } else {
          gaps[i] = {
            promedio: totalSorteos,
            frecuencia: 0,
            probabilidadProxima: 0.1 // Baja probabilidad para n√∫meros que no han salido
          };
        }
      }
      
      // N√∫meros con gap alto (candidatos a salir pronto)
      const numerosPorGap = Object.entries(gaps)
        .sort((a, b) => b[1].promedio - a[1].promedio)
        .slice(0, 15)
        .map(([num]) => parseInt(num));
      
      return {
        gaps,
        numerosPorGap
      };
    }
    
    // 7. An√°lisis de pares/parejas frecuentes  
    function analizarParejasRecurrentes(numeros) {
      const parejas = {};
      const sorteoCompleto = [];
      
      // Agrupar n√∫meros por sorteo
      for (let i = 0; i < numeros.length; i += 6) {
        const sorteo = numeros.slice(i, i + 6).sort((a, b) => a - b);
        sorteoCompleto.push(sorteo);
      }
      
      // Analizar parejas en cada sorteo
      sorteoCompleto.forEach(sorteo => {
        for (let i = 0; i < sorteo.length; i++) {
          for (let j = i + 1; j < sorteo.length; j++) {
            const pareja = `${sorteo[i]}-${sorteo[j]}`;
            parejas[pareja] = (parejas[pareja] || 0) + 1;
          }
        }
      });
      
      // Top parejas m√°s frecuentes
      const parejasTop = Object.entries(parejas)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20)
        .map(([pareja, freq]) => ({
          numeros: pareja.split('-').map(n => parseInt(n)),
          frecuencia: freq
        }));
      
      return {
        parejas,
        parejasTop
      };
    }
    
    // 8. An√°lisis de distribuci√≥n por d√©cadas
    function analizarDistribucionDecadas(numeros) {
      const decadas = {
        'd1': { rango: [1, 10], count: 0, numeros: [] },
        'd2': { rango: [11, 20], count: 0, numeros: [] },
        'd3': { rango: [21, 30], count: 0, numeros: [] },
        'd4': { rango: [31, 40], count: 0, numeros: [] },
        'd5': { rango: [41, 50], count: 0, numeros: [] },
        'd6': { rango: [51, 56], count: 0, numeros: [] }
      };
      
      numeros.forEach(num => {
        Object.keys(decadas).forEach(decada => {
          const [min, max] = decadas[decada].rango;
          if (num >= min && num <= max) {
            decadas[decada].count++;
            decadas[decada].numeros.push(num);
          }
        });
      });
      
      // Calcular distribuci√≥n ideal vs real
      const totalNumeros = numeros.length;
      const distribuciones = {};
      
      Object.keys(decadas).forEach(decada => {
        const rangoSize = decadas[decada].rango[1] - decadas[decada].rango[0] + 1;
        const esperado = (rangoSize / 56) * totalNumeros;
        const real = decadas[decada].count;
        distribuciones[decada] = {
          esperado,
          real,
          desviacion: (real - esperado) / esperado,
          rangoSize
        };
      });
      
      return {
        decadas,
        distribuciones
      };
    }
    
    // 9. An√°lisis de balance par/impar optimizado
    function analizarBalanceParImpar(numeros) {
      let pares = 0;
      let impares = 0;
      const sorteos = [];
      
      // Analizar balance por sorteo
      for (let i = 0; i < numeros.length; i += 6) {
        const sorteo = numeros.slice(i, i + 6);
        const paresSorteo = sorteo.filter(n => n % 2 === 0).length;
        const imparesSorteo = sorteo.filter(n => n % 2 === 1).length;
        
        sorteos.push({
          pares: paresSorteo,
          impares: imparesSorteo,
          balance: paresSorteo - imparesSorteo
        });
        
        pares += paresSorteo;
        impares += imparesSorteo;
      }
      
      // Distribuci√≥n m√°s com√∫n de pares/impares
      const distribucionesComunes = {};
      sorteos.forEach(s => {
        const key = `${s.pares}p-${s.impares}i`;
        distribucionesComunes[key] = (distribucionesComunes[key] || 0) + 1;
      });
      
      const distribucionOptima = Object.entries(distribucionesComunes)
        .sort((a, b) => b[1] - a[1])[0];
      
      return {
        totalPares: pares,
        totalImpares: impares,
        ratio: pares / impares,
        distribucionOptima: distribucionOptima ? distribucionOptima[0] : '3p-3i',
        sorteos
      };
    }
    
    // 10. An√°lisis de secuencias y saltos
    function analizarSecuenciasYSaltos(numeros) {
      const secuencias = [];
      const saltos = [];
      
      // Analizar por sorteo
      for (let i = 0; i < numeros.length; i += 6) {
        const sorteo = numeros.slice(i, i + 6).sort((a, b) => a - b);
        
        // Detectar secuencias consecutivas
        let secuenciaActual = [sorteo[0]];
        for (let j = 1; j < sorteo.length; j++) {
          if (sorteo[j] === sorteo[j-1] + 1) {
            secuenciaActual.push(sorteo[j]);
          } else {
            if (secuenciaActual.length > 1) {
              secuencias.push(secuenciaActual);
            }
            secuenciaActual = [sorteo[j]];
          }
        }
        if (secuenciaActual.length > 1) {
          secuencias.push(secuenciaActual);
        }
        
        // Calcular saltos entre n√∫meros
        for (let j = 1; j < sorteo.length; j++) {
          saltos.push(sorteo[j] - sorteo[j-1]);
        }
      }
      
      // An√°lisis de saltos m√°s comunes
      const saltosComunes = {};
      saltos.forEach(salto => {
        saltosComunes[salto] = (saltosComunes[salto] || 0) + 1;
      });
      
      const saltosTop = Object.entries(saltosComunes)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([salto, freq]) => ({ salto: parseInt(salto), frecuencia: freq }));
      
      return {
        secuencias,
        saltos,
        saltosComunes,
        saltosTop,
        promedioSalto: saltos.reduce((a, b) => a + b, 0) / saltos.length
      };
    }
    
    // 11. An√°lisis de regresi√≥n a la media
    function analizarRegresionMedia(frecuencias, totalNumeros) {
      const promedio = totalNumeros / 56;
      const regresion = {};
      
      for (let i = 1; i <= 56; i++) {
        const freq = frecuencias[i] || 0;
        const desviacion = freq - promedio;
        const factorRegresion = desviacion / promedio;
        
        // Probabilidad de regresi√≥n (n√∫meros muy altos tienden a bajar, muy bajos a subir)
        regresion[i] = {
          frecuenciaActual: freq,
          desviacion,
          factorRegresion,
          probabilidadRegresion: Math.abs(factorRegresion), // Mayor desviaci√≥n = mayor probabilidad de regresi√≥n
          tendencia: factorRegresion > 0.2 ? 'descendente' : (factorRegresion < -0.2 ? 'ascendente' : 'estable')
        };
      }
      
      // N√∫meros candidatos a ascender (frecuencia muy baja)
      const candidatosAscendentes = Object.entries(regresion)
        .filter(([num, data]) => data.tendencia === 'ascendente')
        .sort((a, b) => b[1].probabilidadRegresion - a[1].probabilidadRegresion)
        .slice(0, 12)
        .map(([num]) => parseInt(num));
      
      return {
        regresion,
        candidatosAscendentes
      };
    }
    
    // === FUNCI√ìN ESPECIAL PARA ADMINISTRADORES ===
    // Calcula el n√∫mero con M√ÅXIMA probabilidad estad√≠stica de salir
    function calcularNumeroMaximaProbabilidad(stats) {
      console.log('üëë Calculando n√∫mero con M√ÅXIMA probabilidad para administrador...');
      
      const puntuacionesMaximas = {};
      
      for (let i = 1; i <= 56; i++) {
        let puntuacionTotal = 0;
        
        // Factor 1: An√°lisis de gaps - prioridad m√°xima (25%)
        if (stats.gaps && stats.gaps.gaps[i]) {
          const gapData = stats.gaps.gaps[i];
          const probabilidadGap = gapData.probabilidadProxima || 0;
          puntuacionTotal += probabilidadGap * 0.25;
        }
        
        // Factor 2: Regresi√≥n a la media - n√∫meros ascendentes (20%)
        if (stats.regresion && stats.regresion.regresion[i]) {
          const regresionData = stats.regresion.regresion[i];
          if (regresionData.tendencia === 'ascendente') {
            puntuacionTotal += regresionData.probabilidadRegresion * 0.20;
          }
        }
        
        // Factor 3: Ciclos temporales - tendencias positivas (20%)
        if (stats.ciclos && stats.ciclos.tendencias[i]) {
          const tendencia = stats.ciclos.tendencias[i];
          if (tendencia > 0) {
            puntuacionTotal += (tendencia * 0.20);
          }
        }
        
        // Factor 4: Frecuencia balanceada hacia la media (15%)
        const freq = stats.frecuenciasNorm[i] || 0;
        const idealFreq = 1/56;
        const balanceFactor = 1 - Math.abs(freq - idealFreq);
        puntuacionTotal += balanceFactor * 0.15;
        
        // Factor 5: An√°lisis de distribuci√≥n por d√©cadas (10%)
        if (stats.decadas && stats.decadas.distribuciones) {
          const decada = Math.floor((i - 1) / 10);
          const claveDecada = `d${decada + 1}`;
          const infoDecada = stats.decadas.distribuciones[claveDecada];
          
          if (infoDecada && infoDecada.desviacion < -0.1) { // D√©cada muy sub-representada
            puntuacionTotal += Math.abs(infoDecada.desviacion) * 0.10;
          }
        }
        
        // Factor 6: Balance estad√≠stico general (10%)
        const esCaliente = stats.calientes.includes(i);
        const esFrio = stats.frios.includes(i);
        
        // N√∫meros en zona media tienen mejor balance estad√≠stico
        if (!esCaliente && !esFrio) {
          puntuacionTotal += 0.10;
        } else if (esFrio) {
          // N√∫meros fr√≠os tienen potencial de regresi√≥n
          puntuacionTotal += 0.05;
        }
        
        puntuacionesMaximas[i] = puntuacionTotal;
      }
      
      // Encontrar el n√∫mero con m√°xima puntuaci√≥n
      const numeroMaximo = Object.entries(puntuacionesMaximas)
        .sort((a, b) => b[1] - a[1])[0];
      
      const numeroGanador = parseInt(numeroMaximo[0]);
      const puntuacionMaxima = numeroMaximo[1];
      
      console.log(`üéØ N√öMERO CON M√ÅXIMA PROBABILIDAD: ${numeroGanador} (puntuaci√≥n: ${puntuacionMaxima.toFixed(4)})`);
      console.log(`üìä Top 5 n√∫meros m√°s probables:`, 
        Object.entries(puntuacionesMaximas)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .map(([num, punt]) => `${num}(${punt.toFixed(3)})`)
          .join(', ')
      );
      
      return {
        numero: numeroGanador,
        puntuacion: puntuacionMaxima,
        topCinco: Object.entries(puntuacionesMaximas)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .map(([num, punt]) => ({ numero: parseInt(num), puntuacion: punt }))
      };
    }
    
    // Funci√≥n principal para generar predicciones con IA (M√ÅXIMA DIFERENCIACI√ìN)
    function generarPrediccionesConIA(datosReales, usuario, hashCSV) {
      console.log('üß† Generando predicciones con IA y an√°lisis estad√≠stico (M√ÅXIMA DIFERENCIACI√ìN)...');
      
      const predicciones = {};
      
      // GENERAR M√öLTIPLES SEEDS √öNICOS PARA M√ÅXIMA DIFERENCIACI√ìN ENTRE USUARIOS
      const baseUserSeed = generarHashSimple(usuario + "_base_" + hashCSV);
      const altUserSeed = generarHashSimple(usuario + "_alt_" + hashCSV + "_ia");
      const mixedSeed = generarHashSimple(usuario + hashCSV + "_mixed_" + Date.now().toString().slice(-4));
      
      // SEEDS ADICIONALES PARA MAYOR VARIABILIDAD
      const uniqueSeed1 = generarHashSimple(usuario.split('_')[0] + "_unique1_" + hashCSV);
      const uniqueSeed2 = generarHashSimple(usuario.split('_')[1] + "_unique2_" + hashCSV);
      const uniqueSeed3 = generarHashSimple(usuario.split('_')[2] + "_unique3_" + hashCSV);
      const timeSeed = generarHashSimple(usuario + "_time_" + Math.floor(Date.now() / 86400000)); // Cambia cada d√≠a
      
      console.log(`üé≤ Usando 7 seeds √∫nicos para usuario: ${usuario.substring(0, 20)}...`);
      
      const sorteos = Object.keys(datosReales);
      for (let index = 0; index < sorteos.length; index++) {
        const sorteo = sorteos[index];
        const datos = datosReales[sorteo];
        
        if (!datos || !datos.estadisticas) {
          predicciones[sorteo] = generarCombinacionFallback(baseUserSeed, index);
          continue;
        }
        
        const stats = datos.estadisticas;
        
        // Combinar los 5 m√©todos de an√°lisis con seeds S√öPER diferenciados
        const combinacion = [];
        
        // M√©todo 1: Frecuencias balanceadas (2 n√∫meros) - Seed √∫nico + √≠ndice √∫nico
        const frecBalanceadas = seleccionarPorFrecuencias(stats.frecuenciasNorm, 
          baseUserSeed + uniqueSeed1 + index * 17);
        combinacion.push(...frecBalanceadas.slice(0, 2));
        
        // M√©todo 2: N√∫meros calientes (1 n√∫mero) - Seed alternativo + rotaci√≥n
        const indiceCaliente = (altUserSeed + uniqueSeed2 + index * 23) % stats.calientes.length;
        const caliente = stats.calientes[indiceCaliente];
        if (!combinacion.includes(caliente)) combinacion.push(caliente);
        
        // M√©todo 3: An√°lisis de suma √≥ptima (1 n√∫mero) - Seed mixto + tiempo
        const sumaOptima = seleccionarPorSuma(stats, 
          mixedSeed + timeSeed + index * 31);
        if (!combinacion.includes(sumaOptima) && combinacion.length < 5) combinacion.push(sumaOptima);
        
        // M√©todo 4: Desviaci√≥n est√°ndar (1 n√∫mero) - Seed combinado m√∫ltiple
        const porDesviacion = seleccionarPorDesviacion(stats, 
          baseUserSeed + altUserSeed + uniqueSeed3 + index * 37);
        if (!combinacion.includes(porDesviacion) && combinacion.length < 6) combinacion.push(porDesviacion);
        
        // M√©todo 5: IA - Completar con an√°lisis de patrones usando seed √∫nico por posici√≥n
        let intentos = 0;
        while (combinacion.length < 6 && intentos < 20) {
          const posicionSeed = mixedSeed + baseUserSeed + uniqueSeed1 + uniqueSeed2 + 
                              index * 41 + combinacion.length * 43 + intentos * 7;
          const iaNumber = generarNumeroIA(stats, posicionSeed, combinacion);
          if (!combinacion.includes(iaNumber)) {
            combinacion.push(iaNumber);
          }
          intentos++;
        }
        
        // Si a√∫n faltan n√∫meros, usar generaci√≥n h√≠brida
        while (combinacion.length < 6) {
          const hybridSeed = uniqueSeed3 + timeSeed + baseUserSeed + combinacion.length * 53;
          const num = (hybridSeed % 56) + 1;
          if (!combinacion.includes(num)) {
            combinacion.push(num);
          }
        }
        
        // Ordenar y formatear
        combinacion.sort((a, b) => a - b);
        predicciones[sorteo] = combinacion.join(' - ');
        
        console.log(`üéØ ${sorteo}: ${predicciones[sorteo]} (seeds: ${[baseUserSeed, altUserSeed, mixedSeed].map(s => s.toString().slice(-4)).join(',')})`);
      }
      
      return predicciones;
    }
    
    // Funciones auxiliares para cada m√©todo de an√°lisis
    function seleccionarPorFrecuencias(frecNorm, seed) {
      const numeros = [];
      const probabilidades = [];
      
      for (let i = 1; i <= 56; i++) {
        // Balancear: ni muy frecuentes ni muy raros
        const freq = frecNorm[i] || 0;
        const ideal = 1/56; // Frecuencia ideal
        const distancia = Math.abs(freq - ideal);
        const prob = Math.max(0.1, 1 - distancia * 10); // Probabilidad inversamente proporcional a la distancia
        
        numeros.push(i);
        probabilidades.push(prob);
      }
      
      return seleccionarConProbabilidad(numeros, probabilidades, seed, 2);
    }
    
    function seleccionarPorSuma(stats, seed) {
      // Buscar n√∫meros que contribuyan a una suma cercana al promedio
      const sumaTarget = stats.promSuma;
      const candidatos = [];
      
      for (let i = 1; i <= 56; i++) {
        // Preferir n√∫meros que est√°n en el rango de suma √≥ptima
        const contrib = i / 6; // Contribuci√≥n promedio de este n√∫mero
        const distancia = Math.abs(contrib - sumaTarget/6);
        const peso = Math.max(0.1, 1 - distancia/10);
        candidatos.push({numero: i, peso: peso});
      }
      
      candidatos.sort((a, b) => b.peso - a.peso);
      const index = Math.abs(seed * 7) % Math.min(10, candidatos.length);
      return candidatos[index].numero;
    }
    
    function seleccionarPorDesviacion(stats, seed) {
      // Seleccionar n√∫meros con desviaci√≥n moderada (ni outliers positivos ni negativos extremos)
      const promedio = stats.totalSorteos / 56 * 6; // Frecuencia promedio esperada
      const candidatos = [];
      
      Object.entries(stats.frecuenciasNorm).forEach(([num, freq]) => {
        const numero = parseInt(num);
        const frecEsperada = promedio / stats.totalSorteos;
        const desviacion = Math.abs(freq - frecEsperada);
        
        // Preferir desviaciones moderadas
        const peso = Math.max(0.1, 1 - desviacion * 5);
        candidatos.push({numero: numero, peso: peso});
      });
      
      candidatos.sort((a, b) => b.peso - a.peso);
      const index = Math.abs(seed * 11) % Math.min(15, candidatos.length);
      return candidatos[index].numero;
    }
    
    function generarNumeroIA(stats, seed, yaSeleccionados) {
      // ‚≠ê VERIFICAR SI EL USUARIO ES ADMINISTRADOR PARA N√öMERO DE M√ÅXIMA PROBABILIDAD
      // Usar verificaci√≥n r√°pida para evitar problemas de contexto async
      const esAdmin = window.esUsuarioAdminRapido ? window.esUsuarioAdminRapido() : false;
      
      if (esAdmin) {
        console.log('üëë MODO ADMINISTRADOR: Intentando incluir n√∫mero de m√°xima probabilidad...');
        
        // Calcular n√∫mero con m√°xima probabilidad estad√≠stica
        const numeroMaxProb = calcularNumeroMaximaProbabilidad(stats);
        
        // Si el n√∫mero de m√°xima probabilidad no est√° ya seleccionado, darlo con alta prioridad
        if (!yaSeleccionados.includes(numeroMaxProb.numero)) {
          console.log(`üéØ ADMIN: N√∫mero de m√°xima probabilidad disponible: ${numeroMaxProb.numero}`);
          
          // Para administradores, hay 50% de probabilidad de que reciban el n√∫mero de m√°xima probabilidad
          const probabilidadAdmin = ((seed * 13) % 100) < 50;
          
          if (probabilidadAdmin) {
            console.log(`‚úÖ ADMIN: Entregando n√∫mero de M√ÅXIMA PROBABILIDAD: ${numeroMaxProb.numero} (puntuaci√≥n: ${numeroMaxProb.puntuacion.toFixed(4)})`);
            return numeroMaxProb.numero;
          } else {
            console.log(`üé≤ ADMIN: Usando algoritmo est√°ndar (variabilidad del 50%)`);
          }
        } else {
          console.log(`‚ö†Ô∏è ADMIN: N√∫mero de m√°xima probabilidad ya seleccionado: ${numeroMaxProb.numero}`);
        }
      }
      
      // IA AVANZADA: Algoritmo est√°ndar para usuarios regulares y administradores (variabilidad)
      const candidatos = [];
      
      for (let i = 1; i <= 56; i++) {
        if (yaSeleccionados.includes(i)) continue;
        
        let puntuacion = 0;
        
        // Factor 1: Frecuencia balanceada (15% - reducido para dar espacio a nuevos factores)
        const freq = stats.frecuenciasNorm[i] || 0;
        const idealFreq = 1/56;
        puntuacion += (1 - Math.abs(freq - idealFreq) * 2) * 0.15;
        
        // Factor 2: An√°lisis de ciclos temporales (15%)
        if (stats.ciclos && stats.ciclos.tendencias[i]) {
          const tendencia = stats.ciclos.tendencias[i];
          const esCalienteReciente = stats.ciclos.numerosCalientesRecientes.includes(i);
          if (tendencia > 0 || esCalienteReciente) {
            puntuacion += 0.15 * (1 + tendencia * 0.1);
          }
        }
        
        // Factor 3: An√°lisis de gaps - n√∫meros con gap alto tienen mayor probabilidad (15%)
        if (stats.gaps && stats.gaps.gaps[i]) {
          const probabilidadGap = stats.gaps.gaps[i].probabilidadProxima || 0;
          const esNumeroConGapAlto = stats.gaps.numerosPorGap.includes(i);
          if (esNumeroConGapAlto) {
            puntuacion += 0.15 * probabilidadGap;
          }
        }
        
        // Factor 4: An√°lisis de pares frecuentes (10%)
        if (stats.pares && stats.pares.parejasTop) {
          let factorPares = 0;
          yaSeleccionados.forEach(numSeleccionado => {
            const existePareja = stats.pares.parejasTop.find(pareja => 
              pareja.numeros.includes(i) && pareja.numeros.includes(numSeleccionado)
            );
            if (existePareja) {
              factorPares += existePareja.frecuencia / 100; // Normalizar frecuencia
            }
          });
          puntuacion += Math.min(factorPares, 0.1); // M√°ximo 10%
        }
        
        // Factor 5: Balance par/impar optimizado (10%)
        const pares = yaSeleccionados.filter(n => n % 2 === 0).length;
        const impares = yaSeleccionados.length - pares;
        if (stats.parImpar && stats.parImpar.distribucionOptima) {
          const [paresOpt, imparesOpt] = stats.parImpar.distribucionOptima.match(/\d+/g).map(Number);
          if ((i % 2 === 0 && pares < paresOpt) || (i % 2 === 1 && impares < imparesOpt)) {
            puntuacion += 0.1;
          }
        } else {
          // Fallback al balance 3-3
          if ((i % 2 === 0 && pares < 3) || (i % 2 === 1 && impares < 3)) {
            puntuacion += 0.1;
          }
        }
        
        // Factor 6: Distribuci√≥n por d√©cadas mejorada (10%)
        if (stats.decadas && stats.decadas.distribuciones) {
          const decada = Math.floor((i - 1) / 10);
          const claveDecada = `d${decada + 1}`;
          const infoDecada = stats.decadas.distribuciones[claveDecada];
          
          if (infoDecada && infoDecada.desviacion < 0) { // D√©cada sub-representada
            puntuacion += 0.1 * Math.abs(infoDecada.desviacion);
          }
          
          // Bonus si no hay n√∫meros de esta d√©cada seleccionados
          const enDecada = yaSeleccionados.filter(n => Math.floor((n - 1) / 10) === decada).length;
          if (enDecada === 0) puntuacion += 0.05;
        }
        
        // Factor 7: An√°lisis de regresi√≥n a la media (10%)
        if (stats.regresion && stats.regresion.regresion[i]) {
          const regresionData = stats.regresion.regresion[i];
          if (regresionData.tendencia === 'ascendente') {
            puntuacion += 0.1 * regresionData.probabilidadRegresion;
          }
          
          // Bonus para candidatos ascendentes identificados
          if (stats.regresion.candidatosAscendentes.includes(i)) {
            puntuacion += 0.05;
          }
        }
        
        // Factor 8: An√°lisis de secuencias y saltos (5%)
        if (stats.secuencias && yaSeleccionados.length > 0) {
          const ultimoSeleccionado = Math.max(...yaSeleccionados);
          const salto = Math.abs(i - ultimoSeleccionado);
          
          // Favorecer saltos comunes
          if (stats.secuencias.saltosTop) {
            const saltoComun = stats.secuencias.saltosTop.find(s => s.salto === salto);
            if (saltoComun) {
              puntuacion += 0.05 * (saltoComun.frecuencia / Math.max(...stats.secuencias.saltosTop.map(s => s.frecuencia)));
            }
          }
        }
        
        // Factor 9: Evitar extremos de frecuencia (5%)
        const esCaliente = stats.calientes.includes(i);
        const esFrio = stats.frios.includes(i);
        if (!esCaliente && !esFrio) {
          puntuacion += 0.05;
        }
        
        // Factor 10: Bonus aleatorio controlado para variabilidad (5%)
        const bonusAleatorio = ((seed * i * 7) % 100) / 1000; // 0-0.1
        puntuacion += bonusAleatorio * 0.05;
        
        candidatos.push({numero: i, puntuacion: puntuacion});
      }
      
      candidatos.sort((a, b) => b.puntuacion - a.puntuacion);
      
      // Seleccionar con algoritmo mejorado de aleatoriedad controlada
      const topCandidatos = candidatos.slice(0, Math.min(15, candidatos.length));
      
      // Usar distribuci√≥n ponderada en lugar de selecci√≥n uniforme
      const pesos = topCandidatos.map((c, idx) => Math.max(0.1, 1 - (idx * 0.1))); // Peso decreciente
      const sumaTotal = pesos.reduce((a, b) => a + b, 0);
      const target = ((seed * 23) % 10000) / 10000;
      
      let acumulado = 0;
      for (let i = 0; i < topCandidatos.length; i++) {
        acumulado += pesos[i] / sumaTotal;
        if (target <= acumulado) {
          return topCandidatos[i].numero;
        }
      }
      
      // Fallback
      return topCandidatos[0].numero;
    }
    
    function seleccionarConProbabilidad(numeros, probabilidades, seed, cantidad) {
      const seleccionados = [];
      const numerosDisponibles = [...numeros];
      const probDisponibles = [...probabilidades];
      
      for (let i = 0; i < cantidad && numerosDisponibles.length > 0; i++) {
        // Normalizar probabilidades
        const sumProb = probDisponibles.reduce((a, b) => a + b, 0);
        const probNorm = probDisponibles.map(p => p / sumProb);
        
        // Selecci√≥n seudo-aleatoria basada en probabilidades
        let acumulada = 0;
        const target = ((seed * (i + 1) * 7) % 10000) / 10000;
        
        for (let j = 0; j < probNorm.length; j++) {
          acumulada += probNorm[j];
          if (target <= acumulada) {
            seleccionados.push(numerosDisponibles[j]);
            numerosDisponibles.splice(j, 1);
            probDisponibles.splice(j, 1);
            break;
          }
        }
      }
      
      return seleccionados;
    }
    
    // Funci√≥n fallback mejorada con mayor diferenciaci√≥n por usuario
    function generarPrediccionesFallback(usuario, hashCSV) {
      // M√∫ltiples seeds para mayor variabilidad
      const userSeed1 = generarHashSimple(usuario + "_fallback_" + hashCSV);
      const userSeed2 = generarHashSimple(usuario + hashCSV + "_backup");
      const userSeed3 = generarHashSimple(hashCSV + "_" + usuario + "_emergency");
      
      return {
        melate: generarCombinacionFallback(userSeed1, 0),
        revancha: generarCombinacionFallback(userSeed2, 1),
        revanchita: generarCombinacionFallback(userSeed3, 2)
      };
    }
    
    function generarCombinacionFallback(seed, sorteoIndex) {
      const nums = new Set();
      let attempts = 0;
      
      // Usar m√∫ltiples factores para mayor diversidad
      const baseSeed = seed + sorteoIndex * 47;
      
      while (nums.size < 6 && attempts < 100) {
        // Combinar m√∫ltiples operaciones para mejor distribuci√≥n
        const factor1 = (baseSeed * (attempts + 1) * 17) % 56;
        const factor2 = (baseSeed + attempts * 23) % 56;
        const factor3 = ((baseSeed ^ attempts) * 31) % 56;
        
        const num = Math.abs(factor1 ^ factor2 ^ factor3) % 56 + 1;
        nums.add(num);
        attempts++;
      }
      
      return [...nums].sort((a, b) => a - b).join(' - ');
    }
    
    // ==================== SISTEMA DE SORTEOS POR USUARIO ====================
    
    // Variables para controlar cambios en CSV y sorteos por usuario
    let sorteosPorUsuario = {};
    
    // Funci√≥n para generar hash robusto de un string (M√ÅXIMA DISTRIBUCI√ìN)
    function generarHashSimple(str) {
      // Usar m√∫ltiples algoritmos de hash para mejor distribuci√≥n
      let hash1 = 5381; // DJB2 hash
      let hash2 = 0;    // Simple hash
      let hash3 = 1;    // Multiplicative hash
      
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        
        // Hash 1: DJB2
        hash1 = ((hash1 << 5) + hash1) + char;
        
        // Hash 2: Additive with rotation
        hash2 = (hash2 * 31 + char) & 0x7fffffff;
        
        // Hash 3: Multiplicative
        hash3 = (hash3 * 16777619) ^ char;
      }
      
      // Combinar los tres hashes con operaciones adicionales
      let finalHash = hash1 ^ hash2 ^ hash3;
      
      // Aplicar m√°s transformaciones para mejor distribuci√≥n
      finalHash = finalHash ^ (finalHash >>> 16);
      finalHash = Math.imul(finalHash, 0x85ebca6b);
      finalHash = finalHash ^ (finalHash >>> 13);
      finalHash = Math.imul(finalHash, 0xc2b2ae35);
      finalHash = finalHash ^ (finalHash >>> 16);
      
      // Agregar factor adicional basado en la longitud de la cadena
      finalHash = finalHash ^ (str.length * 0x9e3779b9);
      
      return Math.abs(finalHash);
    }
    
    // Funci√≥n para obtener sorteo √∫nico por usuario basado en hash CSV
    function obtenerSorteoParaUsuario(usuario, ultimoSorteoCSV, hashCSV) {
      // El pr√≥ximo sorteo es simplemente el √∫ltimo + 1
      // Todos los usuarios deben ver el mismo pr√≥ximo n√∫mero de sorteo oficial
      const proximoSorteo = ultimoSorteoCSV + 1;
      
      console.log(`üéØ Pr√≥ximo sorteo oficial: ${proximoSorteo} (√∫ltimo CSV: ${ultimoSorteoCSV})`);
      return proximoSorteo;
    }
    
    // Funci√≥n para cargar predicciones persistentes inmediatamente (sin esperar)
    async function cargarPrediccionesPersistentesInmediato() {
      try {
        console.log('‚ö° Verificando predicciones persistentes inmediatas...');
        
        // Cargar del localStorage
        cargarPrediccionesPersistentes();
        
        // Calcular hash CSV
        await calcularHashCSV();
        
        // USAR ID √öNICO ESTABLE (mismo que usa ejecutarPrediccionesIA)
        let usuarioId = generarIDUsuarioUnico();
        const claveUsuarioHash = `${usuarioId}_${csvHashActual}`;
        
        console.log(`üîç Buscando predicciones con clave: ${claveUsuarioHash.substring(0, 30)}...`);
        console.log(`üìä Claves disponibles en localStorage: ${Object.keys(prediccionesPorUsuarioYHash).length}`);
        
        // Si hay predicciones persistentes, mostrarlas inmediatamente
        if (prediccionesPorUsuarioYHash[claveUsuarioHash]) {
          const predicciones = prediccionesPorUsuarioYHash[claveUsuarioHash];
          const melateElement = document.getElementById('combinacion-melate');
          const revanchaElement = document.getElementById('combinacion-revancha');
          const revanchitaElement = document.getElementById('combinacion-revanchita');
          const mensajeEstado = document.getElementById('mensaje-estado');
          
          console.log('üéØ PREDICCIONES ENCONTRADAS:');
          console.log('- Melate:', predicciones.melate);
          console.log('- Revancha:', predicciones.revancha);
          console.log('- Revanchita:', predicciones.revanchita);
          
          // Mostrar predicciones solo si los elementos est√°n vac√≠os
          if (melateElement && melateElement.textContent === '-- -- -- -- -- --') {
            melateElement.textContent = predicciones.melate;
            console.log('‚úÖ Melate actualizado');
          }
          if (revanchaElement && revanchaElement.textContent === '-- -- -- -- -- --') {
            revanchaElement.textContent = predicciones.revancha;
            console.log('‚úÖ Revancha actualizado');
          }
          if (revanchitaElement && revanchitaElement.textContent === '-- -- -- -- -- --') {
            revanchitaElement.textContent = predicciones.revanchita;
            console.log('‚úÖ Revanchita actualizado');
          }
          if (mensajeEstado) {
            mensajeEstado.textContent = 'Predicciones persistentes cargadas instant√°neamente';
          }
          
          console.log('‚ö° Predicciones persistentes cargadas inmediatamente desde localStorage');
          return true; // Indicar que se cargaron predicciones
        } else {
          console.log('‚ùå No se encontraron predicciones persistentes para esta clave');
          console.log('üîë Clave buscada:', claveUsuarioHash.substring(0, 50) + '...');
          return false; // Indicar que no se encontraron predicciones
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error en carga inmediata de predicciones:', error);
        return false;
      }
    }

    // Hacer funciones disponibles globalmente
    window.toggleAleatorias = toggleAleatorias;
    window.togglePrediccionIA = togglePrediccionIA;
    window.toggleAnalisis = toggleAnalisis;
    window.generarAleatorias = generarAleatorias;
    window.copiarCombinacion = copiarCombinacion;
    window.ejecutarPrediccionesIA = ejecutarPrediccionesIA;
    
    // === FUNCIONES ESPECIALES PARA ADMINISTRADORES ===
    
    // Funci√≥n para mostrar informaci√≥n detallada de predicciones (solo admins)
    window.verDetallesPrediccionAdmin = function() {
      if (!esUsuarioAdmin()) {
        console.log('‚ùå Acceso denegado: Solo para administradores');
        return;
      }
      
      console.log('üëë ======= DETALLES DE PREDICCI√ìN PARA ADMINISTRADOR =======');
      console.log('üìß Email admin:', window.usuarioActualEmail);
      console.log('üîë Usuario ID:', window.usuarioActualID);
      console.log('üìä Hash CSV actual:', csvHashActual);
      console.log('üíæ Predicciones en cach√©:', Object.keys(prediccionesPorUsuarioYHash).length);
      
      // Mostrar pr√≥ximo n√∫mero de m√°xima probabilidad para cada sorteo
      ejecutarAnalisisAdminCompleto();
    };
    
    // Funci√≥n de an√°lisis completo para administradores
    async function ejecutarAnalisisAdminCompleto() {
      try {
        console.log('üîç Ejecutando an√°lisis completo para administrador...');
        
        const datosReales = await cargarDatosRealesParaIA();
        
        ['melate', 'revancha', 'revanchita'].forEach(sorteo => {
          const datos = datosReales[sorteo];
          if (datos && datos.numeros && datos.frecuencias) {
            const stats = calcularEstadisticas(datos.numeros, datos.frecuencias, datos.sumas || []);
            const numeroMaxProb = calcularNumeroMaximaProbabilidad(stats);
            
            console.log(`üéØ ${sorteo.toUpperCase()}: N√∫mero con m√°xima probabilidad: ${numeroMaxProb.numero} (puntuaci√≥n: ${numeroMaxProb.puntuacion.toFixed(4)})`);
            console.log(`   üìà Top 3:`, numeroMaxProb.topCinco.slice(0, 3).map(n => `${n.numero}(${n.puntuacion.toFixed(3)})`).join(', '));
          }
        });
        
        console.log('‚úÖ An√°lisis completo finalizado');
        
      } catch (error) {
        console.error('‚ùå Error en an√°lisis de administrador:', error);
      }
    }
    
    // FUNCI√ìN ADICIONAL: Limpiar predicciones persistentes (solo para administradores)
    window.limpiarPrediccionesPersistentes = function() {
      try {
        prediccionesPorUsuarioYHash = {};
        localStorage.removeItem('yaViPrediccionesIA');
        localStorage.removeItem('yaViCSVHash');
        csvHashActual = null;
        csvHashCalculado = false;
        console.log('üßπ Predicciones persistentes limpiadas. Se generar√°n nuevas predicciones.');
        alert('‚úÖ Predicciones limpiadas. Refresca la p√°gina para generar nuevas predicciones.');
      } catch (error) {
        console.error('‚ùå Error limpiando predicciones:', error);
      }
    };
    
    // FUNCI√ìN DE TESTING: Generar m√∫ltiples IDs para verificar unicidad
    window.testUnicidadUsuarios = function(cantidad = 10) {
      console.log('üß™ TESTING: Generando m√∫ltiples IDs para verificar unicidad...');
      const idsGenerados = new Set();
      const duplicados = [];
      
      for (let i = 0; i < cantidad; i++) {
        const id = generarIDUsuarioUnico();
        if (idsGenerados.has(id)) {
          duplicados.push(id);
        } else {
          idsGenerados.add(id);
        }
        console.log(`ID ${i + 1}: ${id.substring(0, 30)}...`);
      }
      
      console.log(`‚úÖ Resultados del test:`);
      console.log(`- IDs √∫nicos generados: ${idsGenerados.size}/${cantidad}`);
      console.log(`- Duplicados encontrados: ${duplicados.length}`);
      console.log(`- Tasa de unicidad: ${((idsGenerados.size / cantidad) * 100).toFixed(2)}%`);
      
      if (duplicados.length === 0) {
        console.log('üéâ EXCELENTE: Todos los IDs son √∫nicos');
      } else {
        console.warn('‚ö†Ô∏è ADVERTENCIA: Se encontraron duplicados');
      }
      
      return {
        total: cantidad,
        unicos: idsGenerados.size,
        duplicados: duplicados.length,
        tasaUnicidad: (idsGenerados.size / cantidad) * 100
      };
    };
    
    console.log('‚úÖ Todas las funciones cargadas correctamente');
    console.log('üîí Sistema de predicciones PERSISTENTES activado');
    
    // Event listener para detectar navegaci√≥n del navegador y cargar predicciones persistentes
    window.addEventListener('pageshow', function(event) {
      console.log('üìÑ P√°gina mostrada (pageshow event)');
      
      // Cargar predicciones persistentes cuando se muestra la p√°gina
      setTimeout(() => {
        cargarPrediccionesPersistentesInmediato();
      }, 200);
    });
    
    // Event listener adicional para cuando el DOM est√© completamente cargado
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        console.log('üìÑ DOM cargado completamente');
        setTimeout(() => {
          cargarPrediccionesPersistentesInmediato();
        }, 300);
      });
    } else {
      // El DOM ya est√° cargado
      setTimeout(() => {
        cargarPrediccionesPersistentesInmediato();
      }, 100);
    }
    
    // EVENTO ESPECIAL: Verificar y restaurar predicciones cada 2 segundos
    let verificacionInterval = setInterval(() => {
      const melateElement = document.getElementById('combinacion-melate');
      const revanchaElement = document.getElementById('combinacion-revancha');
      const revanchitaElement = document.getElementById('combinacion-revanchita');
      
      // Si los elementos existen pero est√°n vac√≠os, intentar cargar predicciones
      if (melateElement && revanchaElement && revanchitaElement) {
        const melateVacio = melateElement.textContent === '-- -- -- -- -- --';
        const revanchaVacio = revanchaElement.textContent === '-- -- -- -- -- --';
        const revanchitaVacio = revanchitaElement.textContent === '-- -- -- -- -- --';
        
        if (melateVacio && revanchaVacio && revanchitaVacio) {
          console.log('üîÑ Detectados elementos vac√≠os, intentando cargar predicciones persistentes...');
          cargarPrediccionesPersistentesInmediato();
        } else if (!melateVacio && !revanchaVacio && !revanchitaVacio) {
          // Si ya hay predicciones cargadas, detener la verificaci√≥n
          console.log('‚úÖ Predicciones ya cargadas, deteniendo verificaci√≥n autom√°tica');
          clearInterval(verificacionInterval);
        }
      }
    }, 2000); // Verificar cada 2 segundos
    
    // Detener verificaci√≥n despu√©s de 30 segundos para no consumir recursos infinitamente
    setTimeout(() => {
      clearInterval(verificacionInterval);
      console.log('‚è∞ Verificaci√≥n autom√°tica finalizada despu√©s de 30 segundos');
    }, 30000);

    // === NUEVA FUNCIONALIDAD: PREDICCI√ìN PARA EL PR√ìXIMO SORTEO ===
    
    // Funci√≥n para obtener el pr√≥ximo d√≠a de sorteo
    function obtenerProximoDiaSorteo() {
      const ahora = new Date();
      const diaActual = ahora.getDay(); // 0=Domingo, 1=Lunes, 2=Martes, 3=Mi√©rcoles, 4=Jueves, 5=Viernes, 6=S√°bado
      const horaActual = ahora.getHours(); // Hora actual (0-23)
      let proximoDia = '';
      let diasHasta = 0;
      let esHoy = false;

      // Sorteos: Mi√©rcoles, Viernes, Domingo a las 21:00
      // Si es d√≠a de sorteo y antes de las 21:00, mantener el d√≠a
      if ((diaActual === 0 || diaActual === 3 || diaActual === 5) && horaActual < 21) {
        proximoDia = ['domingo','mi√©rcoles','viernes'][[0,3,5].indexOf(diaActual)];
        diasHasta = 0;
        esHoy = true;
      } else {
        if (diaActual === 0) {
          proximoDia = 'mi√©rcoles';
          diasHasta = 3;
        } else if (diaActual === 1 || diaActual === 2) {
          proximoDia = 'mi√©rcoles';
          diasHasta = 3 - diaActual;
        } else if (diaActual === 3) {
          proximoDia = 'viernes';
          diasHasta = 2;
        } else if (diaActual === 4) {
          proximoDia = 'viernes';
          diasHasta = 1;
        } else if (diaActual === 5) {
          proximoDia = 'domingo';
          diasHasta = 2;
        } else if (diaActual === 6) {
          proximoDia = 'domingo';
          diasHasta = 1;
        }
        esHoy = false;
      }

      const fechaProximoSorteo = new Date(ahora);
      fechaProximoSorteo.setDate(ahora.getDate() + diasHasta);

      return {
        dia: proximoDia,
        diasHasta: diasHasta,
        fecha: fechaProximoSorteo,
        esHoy: esHoy
      };
    }
    
    // Funci√≥n para filtrar sorteos por d√≠a espec√≠fico
    function filtrarSorteosPorDia(lineasCSV, diaObjetivo) {
      const sorteosFiltrados = [];
      const numerosDelDia = [];
      
      // Mapeo de d√≠as
      const diasSemana = {
        0: 'domingo',
        1: 'lunes', 
        2: 'martes',
        3: 'mi√©rcoles',
        4: 'jueves',
        5: 'viernes',
        6: 's√°bado'
      };
      
      // Fecha l√≠mite (18 meses atr√°s)
      const fechaActual = new Date();
      const fechaLimite = new Date(fechaActual.getFullYear(), fechaActual.getMonth() - 18, fechaActual.getDate());
      
      for (let i = 1; i < lineasCSV.length; i++) {
        const linea = lineasCSV[i].trim();
        if (!linea) continue;
        
        const columnas = linea.split(',');
        if (columnas.length < 9) continue;
        
        // Obtener fecha
        const fechaStr = columnas[columnas.length - 1].trim();
        if (!fechaStr) continue;
        
        const partesFecha = fechaStr.split('/');
        if (partesFecha.length !== 3) continue;
        
        const dia = parseInt(partesFecha[0]);
        const mes = parseInt(partesFecha[1]) - 1;
        const a√±o = parseInt(partesFecha[2]);
        const fechaSorteo = new Date(a√±o, mes, dia);
        
        // Verificar si est√° dentro del rango de 18 meses
        if (fechaSorteo < fechaLimite) continue;
        
        // Verificar si es el d√≠a objetivo
        const diaSemanaNumero = fechaSorteo.getDay();
        const diaSemanaTexto = diasSemana[diaSemanaNumero];
        
        if (diaSemanaTexto === diaObjetivo) {
          // Extraer n√∫meros ganadores
          const numeros = [];
          const inicioNumeros = (columnas.length === 11) ? 2 : 2; // Melate vs Revancha/Revanchita
          const finNumeros = (columnas.length === 11) ? 7 : 7;
          
          for (let j = inicioNumeros; j <= finNumeros; j++) {
            const num = parseInt(columnas[j]);
            if (!isNaN(num) && num >= 1 && num <= 56) {
              numeros.push(num);
            }
          }
          
          if (numeros.length === 6) {
            sorteosFiltrados.push({
              fecha: fechaStr,
              numeros: numeros,
              concurso: columnas[1]
            });
            numerosDelDia.push(...numeros);
          }
        }
      }
      
      return {
        sorteos: sorteosFiltrados,
        numeros: numerosDelDia,
        total: sorteosFiltrados.length
      };
    }
    
    // Funci√≥n para generar predicci√≥n basada en d√≠a espec√≠fico
    function generarPrediccionParaDia(userId, datosDia, tipoSorteo) {
      if (!datosDia.numeros || datosDia.numeros.length === 0) {
        // Predicciones por defecto
        const prediccionesPorDefecto = {
          melate: [7, 13, 23, 27, 42, 56],
          revancha: [3, 19, 24, 31, 38, 51],
          revanchita: [5, 12, 26, 33, 47, 54]
        };
        return prediccionesPorDefecto[tipoSorteo] || [1, 14, 21, 28, 35, 49];
      }
      
      // Calcular frecuencias
      const frecuencias = {};
      for (let i = 1; i <= 56; i++) {
        frecuencias[i] = 0;
      }
      
      datosDia.numeros.forEach(num => {
        if (num >= 1 && num <= 56) {
          frecuencias[num]++;
        }
      });
      
      // Generar semilla espec√≠fica
      const semilla = hashCodeLocal(`${userId}-${tipoSorteo}-${Date.now()}`);
      
      // Convertir a array y ordenar por score
      const numerosConScore = Object.entries(frecuencias).map(([num, freq]) => ({
        numero: parseInt(num),
        frecuencia: freq,
        score: freq + (semilla % (parseInt(num) + 1)) / 100
      })).sort((a, b) => b.score - a.score);
      
      // Seleccionar 6 n√∫meros
      const seleccionados = [];
      const usados = new Set();
      
      for (let i = 0; i < numerosConScore.length && seleccionados.length < 6; i++) {
        const numero = numerosConScore[i].numero;
        const probabilidad = 0.7 - (i * 0.04) + ((semilla % 100) / 400);
        const aleatorio = (semilla + i * 31) % 100 / 100;
        
        if (aleatorio < probabilidad && !usados.has(numero)) {
          seleccionados.push(numero);
          usados.add(numero);
        }
      }
      
      // Completar si es necesario
      while (seleccionados.length < 6) {
        const numeroAleatorio = ((semilla + seleccionados.length * 43) % 56) + 1;
        if (!usados.has(numeroAleatorio)) {
          seleccionados.push(numeroAleatorio);
          usados.add(numeroAleatorio);
        }
      }
      
      return seleccionados.sort((a, b) => a - b);
    }
    
    // Funci√≥n hash local
    function hashCodeLocal(str) {
      let hash = 0;
      if (str.length === 0) return hash;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash) % 2147483647;
    }
    
    // Funci√≥n principal para cargar predicciones del pr√≥ximo sorteo
    async function cargarPrediccionProximoSorteo() {
      console.log('üìÖ Cargando predicci√≥n para el pr√≥ximo sorteo...');
      
      const proximoSorteo = obtenerProximoDiaSorteo();
      const userId = generarIDUsuarioUnico();
      
      // Actualizar t√≠tulos
      const tituloElement = document.getElementById('titulo-proximo-sorteo');
      const descripcionElement = document.getElementById('descripcion-proximo-sorteo');
      
      if (tituloElement) {
        const textoTitulo = `üìÖ Combinaciones sugeridas en base a los sorteos de LOS DIAS "${proximoSorteo.dia.toUpperCase()}"`;
        tituloElement.textContent = textoTitulo;
      }
      
      if (descripcionElement) {
        descripcionElement.textContent = `Combinaciones inteligentes basadas √∫nicamente en los sorteos de ${proximoSorteo.dia} de los √∫ltimos 18 meses`;
      }
      
      try {
        // Cargar datos de los 3 sorteos
        const archivos = ['assets/Melate.csv', 'assets/Revancha.csv', 'assets/Revanchita.csv'];
        const tipos = ['melate', 'revancha', 'revanchita'];
        const resultados = {};
        
        for (let i = 0; i < archivos.length; i++) {
          const archivo = archivos[i];
          const tipo = tipos[i];
          
          try {
            const response = await fetch(archivo);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const csvText = await response.text();
            const lineas = csvText.trim().split('\n');
            
            const datosFiltrados = filtrarSorteosPorDia(lineas, proximoSorteo.dia);
            const prediccion = generarPrediccionParaDia(userId, datosFiltrados, tipo);
            
            resultados[tipo] = {
              prediccion: prediccion,
              estadisticas: datosFiltrados
            };
            
            // Mostrar predicci√≥n
            const elemento = document.getElementById(`prediccion-${tipo}-dia`);
            const elementoStats = document.getElementById(`stats-${tipo}-dia`);
            
            if (elemento) {
              elemento.textContent = prediccion.join(' - ');
            }
            
            if (elementoStats && datosFiltrados.total > 0) {
              elementoStats.textContent = `Basado en ${datosFiltrados.total} sorteos de ${proximoSorteo.dia}`;
            }
            
            console.log(`‚úÖ ${tipo.toUpperCase()} para ${proximoSorteo.dia}: [${prediccion.join(', ')}] (${datosFiltrados.total} sorteos)`);
            
          } catch (error) {
            console.error(`‚ùå Error cargando ${tipo}:`, error);
            
            // Mostrar predicci√≥n por defecto
            const prediccionDefecto = generarPrediccionParaDia(userId, { numeros: [] }, tipo);
            const elemento = document.getElementById(`prediccion-${tipo}-dia`);
            const elementoStats = document.getElementById(`stats-${tipo}-dia`);
            
            if (elemento) {
              elemento.textContent = prediccionDefecto.join(' - ');
            }
            if (elementoStats) {
              elementoStats.textContent = 'Predicci√≥n por defecto';
            }
          }
        }
        
        // Actualizar informaci√≥n del an√°lisis
        const infoElement = document.getElementById('info-analisis-dia');
        if (infoElement) {
          const totalSorteos = Object.values(resultados).reduce((sum, r) => sum + (r.estadisticas?.total || 0), 0);
          const promedioSorteos = Math.round(totalSorteos / 3);
          
          infoElement.innerHTML = `
            <p class="mb-2">üéØ <strong>D√≠a analizado:</strong> ${proximoSorteo.dia.toUpperCase()}</p>
            <p class="mb-2">üìä <strong>Sorteos promedio por juego:</strong> ~${promedioSorteos} sorteos de ${proximoSorteo.dia}</p>
            <p class="mb-2">üìÖ <strong>Per√≠odo:</strong> √öltimos 18 meses (solo ${proximoSorteo.dia}s)</p>
            <p class="text-yellow-200"><strong>üí° Ventaja:</strong> Estas predicciones se basan √∫nicamente en el comportamiento hist√≥rico de los ${proximoSorteo.dia}s, no en datos generales.</p>
          `;
        }
        
      } catch (error) {
        console.error('‚ùå Error general en predicci√≥n del pr√≥ximo sorteo:', error);
      }
    }
    
    // Inicializar la nueva funcionalidad
    setTimeout(() => {
      cargarPrediccionProximoSorteo();
    }, 1000);
  </script>
</body>
</html>
